// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AccessRequest struct {
		Active             func(childComplexity int) int
		Form               func(childComplexity int) int
		GrantedAudiences   func(childComplexity int) int
		GrantedScopes      func(childComplexity int) int
		ID                 func(childComplexity int) int
		Request            func(childComplexity int) int
		RequestedAudiences func(childComplexity int) int
		RequestedScopes    func(childComplexity int) int
	}

	Cert struct {
		ID func(childComplexity int) int
	}

	OIDCAuthCode struct {
		AccessRequest     func(childComplexity int) int
		AuthorizationCode func(childComplexity int) int
		ID                func(childComplexity int) int
		Session           func(childComplexity int) int
	}

	OIDCClient struct {
		ClientID      func(childComplexity int) int
		GrantTypes    func(childComplexity int) int
		ID            func(childComplexity int) int
		RedirectUris  func(childComplexity int) int
		ResponseTypes func(childComplexity int) int
		Scopes        func(childComplexity int) int
		Secret        func(childComplexity int) int
	}

	OIDCSession struct {
		Audiences   func(childComplexity int) int
		AuthTime    func(childComplexity int) int
		ExpiresAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		IssuedAt    func(childComplexity int) int
		Issuer      func(childComplexity int) int
		RequestedAt func(childComplexity int) int
		Subject     func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Node  func(childComplexity int, id int) int
		Nodes func(childComplexity int, ids []int) int
		Users func(childComplexity int) int
	}

	User struct {
		ID          func(childComplexity int) int
		IsActivated func(childComplexity int) int
		Name        func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AccessRequest.active":
		if e.complexity.AccessRequest.Active == nil {
			break
		}

		return e.complexity.AccessRequest.Active(childComplexity), true

	case "AccessRequest.form":
		if e.complexity.AccessRequest.Form == nil {
			break
		}

		return e.complexity.AccessRequest.Form(childComplexity), true

	case "AccessRequest.grantedAudiences":
		if e.complexity.AccessRequest.GrantedAudiences == nil {
			break
		}

		return e.complexity.AccessRequest.GrantedAudiences(childComplexity), true

	case "AccessRequest.grantedScopes":
		if e.complexity.AccessRequest.GrantedScopes == nil {
			break
		}

		return e.complexity.AccessRequest.GrantedScopes(childComplexity), true

	case "AccessRequest.id":
		if e.complexity.AccessRequest.ID == nil {
			break
		}

		return e.complexity.AccessRequest.ID(childComplexity), true

	case "AccessRequest.request":
		if e.complexity.AccessRequest.Request == nil {
			break
		}

		return e.complexity.AccessRequest.Request(childComplexity), true

	case "AccessRequest.requestedAudiences":
		if e.complexity.AccessRequest.RequestedAudiences == nil {
			break
		}

		return e.complexity.AccessRequest.RequestedAudiences(childComplexity), true

	case "AccessRequest.requestedScopes":
		if e.complexity.AccessRequest.RequestedScopes == nil {
			break
		}

		return e.complexity.AccessRequest.RequestedScopes(childComplexity), true

	case "Cert.id":
		if e.complexity.Cert.ID == nil {
			break
		}

		return e.complexity.Cert.ID(childComplexity), true

	case "OIDCAuthCode.accessRequest":
		if e.complexity.OIDCAuthCode.AccessRequest == nil {
			break
		}

		return e.complexity.OIDCAuthCode.AccessRequest(childComplexity), true

	case "OIDCAuthCode.authorizationCode":
		if e.complexity.OIDCAuthCode.AuthorizationCode == nil {
			break
		}

		return e.complexity.OIDCAuthCode.AuthorizationCode(childComplexity), true

	case "OIDCAuthCode.id":
		if e.complexity.OIDCAuthCode.ID == nil {
			break
		}

		return e.complexity.OIDCAuthCode.ID(childComplexity), true

	case "OIDCAuthCode.session":
		if e.complexity.OIDCAuthCode.Session == nil {
			break
		}

		return e.complexity.OIDCAuthCode.Session(childComplexity), true

	case "OIDCClient.clientID":
		if e.complexity.OIDCClient.ClientID == nil {
			break
		}

		return e.complexity.OIDCClient.ClientID(childComplexity), true

	case "OIDCClient.grantTypes":
		if e.complexity.OIDCClient.GrantTypes == nil {
			break
		}

		return e.complexity.OIDCClient.GrantTypes(childComplexity), true

	case "OIDCClient.id":
		if e.complexity.OIDCClient.ID == nil {
			break
		}

		return e.complexity.OIDCClient.ID(childComplexity), true

	case "OIDCClient.redirectUris":
		if e.complexity.OIDCClient.RedirectUris == nil {
			break
		}

		return e.complexity.OIDCClient.RedirectUris(childComplexity), true

	case "OIDCClient.responseTypes":
		if e.complexity.OIDCClient.ResponseTypes == nil {
			break
		}

		return e.complexity.OIDCClient.ResponseTypes(childComplexity), true

	case "OIDCClient.scopes":
		if e.complexity.OIDCClient.Scopes == nil {
			break
		}

		return e.complexity.OIDCClient.Scopes(childComplexity), true

	case "OIDCClient.secret":
		if e.complexity.OIDCClient.Secret == nil {
			break
		}

		return e.complexity.OIDCClient.Secret(childComplexity), true

	case "OIDCSession.audiences":
		if e.complexity.OIDCSession.Audiences == nil {
			break
		}

		return e.complexity.OIDCSession.Audiences(childComplexity), true

	case "OIDCSession.authTime":
		if e.complexity.OIDCSession.AuthTime == nil {
			break
		}

		return e.complexity.OIDCSession.AuthTime(childComplexity), true

	case "OIDCSession.expiresAt":
		if e.complexity.OIDCSession.ExpiresAt == nil {
			break
		}

		return e.complexity.OIDCSession.ExpiresAt(childComplexity), true

	case "OIDCSession.id":
		if e.complexity.OIDCSession.ID == nil {
			break
		}

		return e.complexity.OIDCSession.ID(childComplexity), true

	case "OIDCSession.issuedAt":
		if e.complexity.OIDCSession.IssuedAt == nil {
			break
		}

		return e.complexity.OIDCSession.IssuedAt(childComplexity), true

	case "OIDCSession.issuer":
		if e.complexity.OIDCSession.Issuer == nil {
			break
		}

		return e.complexity.OIDCSession.Issuer(childComplexity), true

	case "OIDCSession.requestedAt":
		if e.complexity.OIDCSession.RequestedAt == nil {
			break
		}

		return e.complexity.OIDCSession.RequestedAt(childComplexity), true

	case "OIDCSession.subject":
		if e.complexity.OIDCSession.Subject == nil {
			break
		}

		return e.complexity.OIDCSession.Subject(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]int)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		return e.complexity.Query.Users(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.isactivated":
		if e.complexity.User.IsActivated == nil {
			break
		}

		return e.complexity.User.IsActivated(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAccessRequestWhereInput,
		ec.unmarshalInputCertWhereInput,
		ec.unmarshalInputOIDCAuthCodeWhereInput,
		ec.unmarshalInputOIDCClientWhereInput,
		ec.unmarshalInputOIDCSessionWhereInput,
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/query.graphql", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
type AccessRequest implements Node {
  id: ID!
  requestedScopes: [String!]!
  grantedScopes: [String!]!
  requestedAudiences: [String!]!
  grantedAudiences: [String!]!
  request: String!
  form: String!
  active: Boolean!
}
"""
AccessRequestWhereInput is used for filtering AccessRequest objects.
Input was generated by ent.
"""
input AccessRequestWhereInput {
  not: AccessRequestWhereInput
  and: [AccessRequestWhereInput!]
  or: [AccessRequestWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """request field predicates"""
  request: String
  requestNEQ: String
  requestIn: [String!]
  requestNotIn: [String!]
  requestGT: String
  requestGTE: String
  requestLT: String
  requestLTE: String
  requestContains: String
  requestHasPrefix: String
  requestHasSuffix: String
  requestEqualFold: String
  requestContainsFold: String
  """form field predicates"""
  form: String
  formNEQ: String
  formIn: [String!]
  formNotIn: [String!]
  formGT: String
  formGTE: String
  formLT: String
  formLTE: String
  formContains: String
  formHasPrefix: String
  formHasSuffix: String
  formEqualFold: String
  formContainsFold: String
  """active field predicates"""
  active: Boolean
  activeNEQ: Boolean
}
type Cert implements Node {
  id: ID!
}
"""
CertWhereInput is used for filtering Cert objects.
Input was generated by ent.
"""
input CertWhereInput {
  not: CertWhereInput
  and: [CertWhereInput!]
  or: [CertWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "github.com/koalatea/authserver/server/ent.Noder") {
  """The id of the object."""
  id: ID!
}
type OIDCAuthCode implements Node {
  id: ID!
  authorizationCode: String!
  accessRequest: AccessRequest
  session: OIDCSession
}
"""
OIDCAuthCodeWhereInput is used for filtering OIDCAuthCode objects.
Input was generated by ent.
"""
input OIDCAuthCodeWhereInput {
  not: OIDCAuthCodeWhereInput
  and: [OIDCAuthCodeWhereInput!]
  or: [OIDCAuthCodeWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """authorization_code field predicates"""
  authorizationCode: String
  authorizationCodeNEQ: String
  authorizationCodeIn: [String!]
  authorizationCodeNotIn: [String!]
  authorizationCodeGT: String
  authorizationCodeGTE: String
  authorizationCodeLT: String
  authorizationCodeLTE: String
  authorizationCodeContains: String
  authorizationCodeHasPrefix: String
  authorizationCodeHasSuffix: String
  authorizationCodeEqualFold: String
  authorizationCodeContainsFold: String
  """access_request edge predicates"""
  hasAccessRequest: Boolean
  hasAccessRequestWith: [AccessRequestWhereInput!]
  """session edge predicates"""
  hasSession: Boolean
  hasSessionWith: [OIDCSessionWhereInput!]
}
type OIDCClient implements Node {
  id: ID!
  clientID: String!
  secret: String!
  redirectUris: [String!]!
  responseTypes: [String!]!
  grantTypes: [String!]!
  scopes: [String!]!
}
"""
OIDCClientWhereInput is used for filtering OIDCClient objects.
Input was generated by ent.
"""
input OIDCClientWhereInput {
  not: OIDCClientWhereInput
  and: [OIDCClientWhereInput!]
  or: [OIDCClientWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """client_id field predicates"""
  clientID: String
  clientIDNEQ: String
  clientIDIn: [String!]
  clientIDNotIn: [String!]
  clientIDGT: String
  clientIDGTE: String
  clientIDLT: String
  clientIDLTE: String
  clientIDContains: String
  clientIDHasPrefix: String
  clientIDHasSuffix: String
  clientIDEqualFold: String
  clientIDContainsFold: String
  """secret field predicates"""
  secret: String
  secretNEQ: String
  secretIn: [String!]
  secretNotIn: [String!]
  secretGT: String
  secretGTE: String
  secretLT: String
  secretLTE: String
  secretContains: String
  secretHasPrefix: String
  secretHasSuffix: String
  secretEqualFold: String
  secretContainsFold: String
}
type OIDCSession implements Node {
  id: ID!
  issuer: String!
  subject: String!
  audiences: [String!]!
  expiresAt: Time!
  issuedAt: Time!
  requestedAt: Time!
  authTime: Time!
}
"""
OIDCSessionWhereInput is used for filtering OIDCSession objects.
Input was generated by ent.
"""
input OIDCSessionWhereInput {
  not: OIDCSessionWhereInput
  and: [OIDCSessionWhereInput!]
  or: [OIDCSessionWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """issuer field predicates"""
  issuer: String
  issuerNEQ: String
  issuerIn: [String!]
  issuerNotIn: [String!]
  issuerGT: String
  issuerGTE: String
  issuerLT: String
  issuerLTE: String
  issuerContains: String
  issuerHasPrefix: String
  issuerHasSuffix: String
  issuerEqualFold: String
  issuerContainsFold: String
  """subject field predicates"""
  subject: String
  subjectNEQ: String
  subjectIn: [String!]
  subjectNotIn: [String!]
  subjectGT: String
  subjectGTE: String
  subjectLT: String
  subjectLTE: String
  subjectContains: String
  subjectHasPrefix: String
  subjectHasSuffix: String
  subjectEqualFold: String
  subjectContainsFold: String
  """expires_at field predicates"""
  expiresAt: Time
  expiresAtNEQ: Time
  expiresAtIn: [Time!]
  expiresAtNotIn: [Time!]
  expiresAtGT: Time
  expiresAtGTE: Time
  expiresAtLT: Time
  expiresAtLTE: Time
  """issued_at field predicates"""
  issuedAt: Time
  issuedAtNEQ: Time
  issuedAtIn: [Time!]
  issuedAtNotIn: [Time!]
  issuedAtGT: Time
  issuedAtGTE: Time
  issuedAtLT: Time
  issuedAtLTE: Time
  """requested_at field predicates"""
  requestedAt: Time
  requestedAtNEQ: Time
  requestedAtIn: [Time!]
  requestedAtNotIn: [Time!]
  requestedAtGT: Time
  requestedAtGTE: Time
  requestedAtLT: Time
  requestedAtLTE: Time
  """auth_time field predicates"""
  authTime: Time
  authTimeNEQ: Time
  authTimeIn: [Time!]
  authTimeNotIn: [Time!]
  authTimeGT: Time
  authTimeGTE: Time
  authTimeLT: Time
  authTimeLTE: Time
}
"""Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument."""
enum OrderDirection {
  """Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  ASC
  """Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}
type Query {
  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: ID!
  ): Node
  """Lookup nodes by a list of IDs."""
  nodes(
    """The list of node IDs."""
    ids: [ID!]!
  ): [Node]!
  users: [User!]!
}
"""The builtin Time type"""
scalar Time
"""
UpdateUserInput is used for update User object.
Input was generated by ent.
"""
input UpdateUserInput {
  """The name displayed for the user"""
  name: String
  """True if the user is active and able to authenticate"""
  isactivated: Boolean
}
type User implements Node {
  id: ID!
  """The name displayed for the user"""
  name: String!
  """True if the user is active and able to authenticate"""
  isactivated: Boolean! @goField(name: "IsActivated", forceResolver: false)
}
"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
  not: UserWhereInput
  and: [UserWhereInput!]
  or: [UserWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """Name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """IsActivated field predicates"""
  isactivated: Boolean
  isactivatedNEQ: Boolean
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
