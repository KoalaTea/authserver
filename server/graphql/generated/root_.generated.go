// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AuthCode struct {
		Active  func(childComplexity int) int
		Code    func(childComplexity int) int
		ID      func(childComplexity int) int
		Session func(childComplexity int) int
	}

	Cert struct {
		ID           func(childComplexity int) int
		Pem          func(childComplexity int) int
		Revoked      func(childComplexity int) int
		SerialNumber func(childComplexity int) int
	}

	DenyListedJTI struct {
		Expiration func(childComplexity int) int
		ID         func(childComplexity int) int
		Jti        func(childComplexity int) int
	}

	Mutation struct {
		RequestCert func(childComplexity int, target string, pubKey string) int
		RevokeCert  func(childComplexity int, serialNumber string) int
	}

	OAuthAccessToken struct {
		ID        func(childComplexity int) int
		Session   func(childComplexity int) int
		Signature func(childComplexity int) int
	}

	OAuthClient struct {
		ClientID      func(childComplexity int) int
		GrantTypes    func(childComplexity int) int
		ID            func(childComplexity int) int
		RedirectUris  func(childComplexity int) int
		ResponseTypes func(childComplexity int) int
		Scopes        func(childComplexity int) int
		Secret        func(childComplexity int) int
	}

	OAuthPARRequest struct {
		ID      func(childComplexity int) int
		Request func(childComplexity int) int
	}

	OAuthRefreshToken struct {
		ID        func(childComplexity int) int
		Session   func(childComplexity int) int
		Signature func(childComplexity int) int
	}

	OAuthSession struct {
		Audiences          func(childComplexity int) int
		AuthTime           func(childComplexity int) int
		ExpiresAt          func(childComplexity int) int
		Form               func(childComplexity int) int
		GrantedAudiences   func(childComplexity int) int
		GrantedScopes      func(childComplexity int) int
		ID                 func(childComplexity int) int
		IssuedAt           func(childComplexity int) int
		Issuer             func(childComplexity int) int
		Request            func(childComplexity int) int
		RequestedAt        func(childComplexity int) int
		RequestedAudiences func(childComplexity int) int
		RequestedScopes    func(childComplexity int) int
		Subject            func(childComplexity int) int
	}

	OIDCAuthCode struct {
		AuthorizationCode func(childComplexity int) int
		ID                func(childComplexity int) int
		Session           func(childComplexity int) int
	}

	PKCE struct {
		Code    func(childComplexity int) int
		ID      func(childComplexity int) int
		Session func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	PublicJWK struct {
		ID     func(childComplexity int) int
		Issuer func(childComplexity int) int
		Key    func(childComplexity int) int
		Kid    func(childComplexity int) int
		Scopes func(childComplexity int) int
		Sid    func(childComplexity int) int
	}

	PublicJWKSet struct {
		ID func(childComplexity int) int
	}

	Query struct {
		Node  func(childComplexity int, id int) int
		Nodes func(childComplexity int, ids []int) int
		Users func(childComplexity int) int
	}

	User struct {
		ID          func(childComplexity int) int
		IsActivated func(childComplexity int) int
		Name        func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AuthCode.active":
		if e.complexity.AuthCode.Active == nil {
			break
		}

		return e.complexity.AuthCode.Active(childComplexity), true

	case "AuthCode.code":
		if e.complexity.AuthCode.Code == nil {
			break
		}

		return e.complexity.AuthCode.Code(childComplexity), true

	case "AuthCode.id":
		if e.complexity.AuthCode.ID == nil {
			break
		}

		return e.complexity.AuthCode.ID(childComplexity), true

	case "AuthCode.session":
		if e.complexity.AuthCode.Session == nil {
			break
		}

		return e.complexity.AuthCode.Session(childComplexity), true

	case "Cert.id":
		if e.complexity.Cert.ID == nil {
			break
		}

		return e.complexity.Cert.ID(childComplexity), true

	case "Cert.pem":
		if e.complexity.Cert.Pem == nil {
			break
		}

		return e.complexity.Cert.Pem(childComplexity), true

	case "Cert.revoked":
		if e.complexity.Cert.Revoked == nil {
			break
		}

		return e.complexity.Cert.Revoked(childComplexity), true

	case "Cert.serialNumber":
		if e.complexity.Cert.SerialNumber == nil {
			break
		}

		return e.complexity.Cert.SerialNumber(childComplexity), true

	case "DenyListedJTI.expiration":
		if e.complexity.DenyListedJTI.Expiration == nil {
			break
		}

		return e.complexity.DenyListedJTI.Expiration(childComplexity), true

	case "DenyListedJTI.id":
		if e.complexity.DenyListedJTI.ID == nil {
			break
		}

		return e.complexity.DenyListedJTI.ID(childComplexity), true

	case "DenyListedJTI.jti":
		if e.complexity.DenyListedJTI.Jti == nil {
			break
		}

		return e.complexity.DenyListedJTI.Jti(childComplexity), true

	case "Mutation.requestCert":
		if e.complexity.Mutation.RequestCert == nil {
			break
		}

		args, err := ec.field_Mutation_requestCert_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RequestCert(childComplexity, args["target"].(string), args["pubKey"].(string)), true

	case "Mutation.revokeCert":
		if e.complexity.Mutation.RevokeCert == nil {
			break
		}

		args, err := ec.field_Mutation_revokeCert_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RevokeCert(childComplexity, args["serialNumber"].(string)), true

	case "OAuthAccessToken.id":
		if e.complexity.OAuthAccessToken.ID == nil {
			break
		}

		return e.complexity.OAuthAccessToken.ID(childComplexity), true

	case "OAuthAccessToken.session":
		if e.complexity.OAuthAccessToken.Session == nil {
			break
		}

		return e.complexity.OAuthAccessToken.Session(childComplexity), true

	case "OAuthAccessToken.signature":
		if e.complexity.OAuthAccessToken.Signature == nil {
			break
		}

		return e.complexity.OAuthAccessToken.Signature(childComplexity), true

	case "OAuthClient.clientID":
		if e.complexity.OAuthClient.ClientID == nil {
			break
		}

		return e.complexity.OAuthClient.ClientID(childComplexity), true

	case "OAuthClient.grantTypes":
		if e.complexity.OAuthClient.GrantTypes == nil {
			break
		}

		return e.complexity.OAuthClient.GrantTypes(childComplexity), true

	case "OAuthClient.id":
		if e.complexity.OAuthClient.ID == nil {
			break
		}

		return e.complexity.OAuthClient.ID(childComplexity), true

	case "OAuthClient.redirectUris":
		if e.complexity.OAuthClient.RedirectUris == nil {
			break
		}

		return e.complexity.OAuthClient.RedirectUris(childComplexity), true

	case "OAuthClient.responseTypes":
		if e.complexity.OAuthClient.ResponseTypes == nil {
			break
		}

		return e.complexity.OAuthClient.ResponseTypes(childComplexity), true

	case "OAuthClient.scopes":
		if e.complexity.OAuthClient.Scopes == nil {
			break
		}

		return e.complexity.OAuthClient.Scopes(childComplexity), true

	case "OAuthClient.secret":
		if e.complexity.OAuthClient.Secret == nil {
			break
		}

		return e.complexity.OAuthClient.Secret(childComplexity), true

	case "OAuthPARRequest.id":
		if e.complexity.OAuthPARRequest.ID == nil {
			break
		}

		return e.complexity.OAuthPARRequest.ID(childComplexity), true

	case "OAuthPARRequest.request":
		if e.complexity.OAuthPARRequest.Request == nil {
			break
		}

		return e.complexity.OAuthPARRequest.Request(childComplexity), true

	case "OAuthRefreshToken.id":
		if e.complexity.OAuthRefreshToken.ID == nil {
			break
		}

		return e.complexity.OAuthRefreshToken.ID(childComplexity), true

	case "OAuthRefreshToken.session":
		if e.complexity.OAuthRefreshToken.Session == nil {
			break
		}

		return e.complexity.OAuthRefreshToken.Session(childComplexity), true

	case "OAuthRefreshToken.signature":
		if e.complexity.OAuthRefreshToken.Signature == nil {
			break
		}

		return e.complexity.OAuthRefreshToken.Signature(childComplexity), true

	case "OAuthSession.audiences":
		if e.complexity.OAuthSession.Audiences == nil {
			break
		}

		return e.complexity.OAuthSession.Audiences(childComplexity), true

	case "OAuthSession.authTime":
		if e.complexity.OAuthSession.AuthTime == nil {
			break
		}

		return e.complexity.OAuthSession.AuthTime(childComplexity), true

	case "OAuthSession.expiresAt":
		if e.complexity.OAuthSession.ExpiresAt == nil {
			break
		}

		return e.complexity.OAuthSession.ExpiresAt(childComplexity), true

	case "OAuthSession.form":
		if e.complexity.OAuthSession.Form == nil {
			break
		}

		return e.complexity.OAuthSession.Form(childComplexity), true

	case "OAuthSession.grantedAudiences":
		if e.complexity.OAuthSession.GrantedAudiences == nil {
			break
		}

		return e.complexity.OAuthSession.GrantedAudiences(childComplexity), true

	case "OAuthSession.grantedScopes":
		if e.complexity.OAuthSession.GrantedScopes == nil {
			break
		}

		return e.complexity.OAuthSession.GrantedScopes(childComplexity), true

	case "OAuthSession.id":
		if e.complexity.OAuthSession.ID == nil {
			break
		}

		return e.complexity.OAuthSession.ID(childComplexity), true

	case "OAuthSession.issuedAt":
		if e.complexity.OAuthSession.IssuedAt == nil {
			break
		}

		return e.complexity.OAuthSession.IssuedAt(childComplexity), true

	case "OAuthSession.issuer":
		if e.complexity.OAuthSession.Issuer == nil {
			break
		}

		return e.complexity.OAuthSession.Issuer(childComplexity), true

	case "OAuthSession.request":
		if e.complexity.OAuthSession.Request == nil {
			break
		}

		return e.complexity.OAuthSession.Request(childComplexity), true

	case "OAuthSession.requestedAt":
		if e.complexity.OAuthSession.RequestedAt == nil {
			break
		}

		return e.complexity.OAuthSession.RequestedAt(childComplexity), true

	case "OAuthSession.requestedAudiences":
		if e.complexity.OAuthSession.RequestedAudiences == nil {
			break
		}

		return e.complexity.OAuthSession.RequestedAudiences(childComplexity), true

	case "OAuthSession.requestedScopes":
		if e.complexity.OAuthSession.RequestedScopes == nil {
			break
		}

		return e.complexity.OAuthSession.RequestedScopes(childComplexity), true

	case "OAuthSession.subject":
		if e.complexity.OAuthSession.Subject == nil {
			break
		}

		return e.complexity.OAuthSession.Subject(childComplexity), true

	case "OIDCAuthCode.authorizationCode":
		if e.complexity.OIDCAuthCode.AuthorizationCode == nil {
			break
		}

		return e.complexity.OIDCAuthCode.AuthorizationCode(childComplexity), true

	case "OIDCAuthCode.id":
		if e.complexity.OIDCAuthCode.ID == nil {
			break
		}

		return e.complexity.OIDCAuthCode.ID(childComplexity), true

	case "OIDCAuthCode.session":
		if e.complexity.OIDCAuthCode.Session == nil {
			break
		}

		return e.complexity.OIDCAuthCode.Session(childComplexity), true

	case "PKCE.code":
		if e.complexity.PKCE.Code == nil {
			break
		}

		return e.complexity.PKCE.Code(childComplexity), true

	case "PKCE.id":
		if e.complexity.PKCE.ID == nil {
			break
		}

		return e.complexity.PKCE.ID(childComplexity), true

	case "PKCE.session":
		if e.complexity.PKCE.Session == nil {
			break
		}

		return e.complexity.PKCE.Session(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "PublicJWK.id":
		if e.complexity.PublicJWK.ID == nil {
			break
		}

		return e.complexity.PublicJWK.ID(childComplexity), true

	case "PublicJWK.issuer":
		if e.complexity.PublicJWK.Issuer == nil {
			break
		}

		return e.complexity.PublicJWK.Issuer(childComplexity), true

	case "PublicJWK.key":
		if e.complexity.PublicJWK.Key == nil {
			break
		}

		return e.complexity.PublicJWK.Key(childComplexity), true

	case "PublicJWK.kid":
		if e.complexity.PublicJWK.Kid == nil {
			break
		}

		return e.complexity.PublicJWK.Kid(childComplexity), true

	case "PublicJWK.scopes":
		if e.complexity.PublicJWK.Scopes == nil {
			break
		}

		return e.complexity.PublicJWK.Scopes(childComplexity), true

	case "PublicJWK.sid":
		if e.complexity.PublicJWK.Sid == nil {
			break
		}

		return e.complexity.PublicJWK.Sid(childComplexity), true

	case "PublicJWKSet.id":
		if e.complexity.PublicJWKSet.ID == nil {
			break
		}

		return e.complexity.PublicJWKSet.ID(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]int)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		return e.complexity.Query.Users(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.isactivated":
		if e.complexity.User.IsActivated == nil {
			break
		}

		return e.complexity.User.IsActivated(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAuthCodeWhereInput,
		ec.unmarshalInputCertWhereInput,
		ec.unmarshalInputDenyListedJTIWhereInput,
		ec.unmarshalInputOAuthAccessTokenWhereInput,
		ec.unmarshalInputOAuthClientWhereInput,
		ec.unmarshalInputOAuthPARRequestWhereInput,
		ec.unmarshalInputOAuthRefreshTokenWhereInput,
		ec.unmarshalInputOAuthSessionWhereInput,
		ec.unmarshalInputOIDCAuthCodeWhereInput,
		ec.unmarshalInputPKCEWhereInput,
		ec.unmarshalInputPublicJWKSetWhereInput,
		ec.unmarshalInputPublicJWKWhereInput,
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/query.graphql", Input: `directive @goField(forceResolver: Boolean, name: String, omittable: Boolean) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!], forceGenerate: Boolean) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
type AuthCode implements Node {
  id: ID!
  code: String!
  active: Boolean!
  """
  information about the request
  """
  session: OAuthSession
}
"""
AuthCodeWhereInput is used for filtering AuthCode objects.
Input was generated by ent.
"""
input AuthCodeWhereInput {
  not: AuthCodeWhereInput
  and: [AuthCodeWhereInput!]
  or: [AuthCodeWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  code field predicates
  """
  code: String
  codeNEQ: String
  codeIn: [String!]
  codeNotIn: [String!]
  codeGT: String
  codeGTE: String
  codeLT: String
  codeLTE: String
  codeContains: String
  codeHasPrefix: String
  codeHasSuffix: String
  codeEqualFold: String
  codeContainsFold: String
  """
  active field predicates
  """
  active: Boolean
  activeNEQ: Boolean
  """
  session edge predicates
  """
  hasSession: Boolean
  hasSessionWith: [OAuthSessionWhereInput!]
}
type Cert implements Node {
  id: ID!
  revoked: Boolean!
  pem: String!
  serialNumber: Int!
}
"""
CertWhereInput is used for filtering Cert objects.
Input was generated by ent.
"""
input CertWhereInput {
  not: CertWhereInput
  and: [CertWhereInput!]
  or: [CertWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  revoked field predicates
  """
  revoked: Boolean
  revokedNEQ: Boolean
  """
  pem field predicates
  """
  pem: String
  pemNEQ: String
  pemIn: [String!]
  pemNotIn: [String!]
  pemGT: String
  pemGTE: String
  pemLT: String
  pemLTE: String
  pemContains: String
  pemHasPrefix: String
  pemHasSuffix: String
  pemEqualFold: String
  pemContainsFold: String
  """
  serial_number field predicates
  """
  serialNumber: Int
  serialNumberNEQ: Int
  serialNumberIn: [Int!]
  serialNumberNotIn: [Int!]
  serialNumberGT: Int
  serialNumberGTE: Int
  serialNumberLT: Int
  serialNumberLTE: Int
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type DenyListedJTI implements Node {
  id: ID!
  jti: String!
  expiration: Time!
}
"""
DenyListedJTIWhereInput is used for filtering DenyListedJTI objects.
Input was generated by ent.
"""
input DenyListedJTIWhereInput {
  not: DenyListedJTIWhereInput
  and: [DenyListedJTIWhereInput!]
  or: [DenyListedJTIWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  jti field predicates
  """
  jti: String
  jtiNEQ: String
  jtiIn: [String!]
  jtiNotIn: [String!]
  jtiGT: String
  jtiGTE: String
  jtiLT: String
  jtiLTE: String
  jtiContains: String
  jtiHasPrefix: String
  jtiHasSuffix: String
  jtiEqualFold: String
  jtiContainsFold: String
  """
  expiration field predicates
  """
  expiration: Time
  expirationNEQ: Time
  expirationIn: [Time!]
  expirationNotIn: [Time!]
  expirationGT: Time
  expirationGTE: Time
  expirationLT: Time
  expirationLTE: Time
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "github.com/koalatea/authserver/server/ent.Noder") {
  """
  The id of the object.
  """
  id: ID!
}
type OAuthAccessToken implements Node {
  id: ID!
  signature: String!
  """
  information about the request
  """
  session: OAuthSession
}
"""
OAuthAccessTokenWhereInput is used for filtering OAuthAccessToken objects.
Input was generated by ent.
"""
input OAuthAccessTokenWhereInput {
  not: OAuthAccessTokenWhereInput
  and: [OAuthAccessTokenWhereInput!]
  or: [OAuthAccessTokenWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  signature field predicates
  """
  signature: String
  signatureNEQ: String
  signatureIn: [String!]
  signatureNotIn: [String!]
  signatureGT: String
  signatureGTE: String
  signatureLT: String
  signatureLTE: String
  signatureContains: String
  signatureHasPrefix: String
  signatureHasSuffix: String
  signatureEqualFold: String
  signatureContainsFold: String
  """
  session edge predicates
  """
  hasSession: Boolean
  hasSessionWith: [OAuthSessionWhereInput!]
}
type OAuthClient implements Node {
  id: ID!
  clientID: String!
  secret: String!
  redirectUris: [String!]!
  responseTypes: [String!]!
  grantTypes: [String!]!
  scopes: [String!]!
}
"""
OAuthClientWhereInput is used for filtering OAuthClient objects.
Input was generated by ent.
"""
input OAuthClientWhereInput {
  not: OAuthClientWhereInput
  and: [OAuthClientWhereInput!]
  or: [OAuthClientWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  client_id field predicates
  """
  clientID: String
  clientIDNEQ: String
  clientIDIn: [String!]
  clientIDNotIn: [String!]
  clientIDGT: String
  clientIDGTE: String
  clientIDLT: String
  clientIDLTE: String
  clientIDContains: String
  clientIDHasPrefix: String
  clientIDHasSuffix: String
  clientIDEqualFold: String
  clientIDContainsFold: String
  """
  secret field predicates
  """
  secret: String
  secretNEQ: String
  secretIn: [String!]
  secretNotIn: [String!]
  secretGT: String
  secretGTE: String
  secretLT: String
  secretLTE: String
  secretContains: String
  secretHasPrefix: String
  secretHasSuffix: String
  secretEqualFold: String
  secretContainsFold: String
}
type OAuthPARRequest implements Node {
  id: ID!
  request: String!
}
"""
OAuthPARRequestWhereInput is used for filtering OAuthPARRequest objects.
Input was generated by ent.
"""
input OAuthPARRequestWhereInput {
  not: OAuthPARRequestWhereInput
  and: [OAuthPARRequestWhereInput!]
  or: [OAuthPARRequestWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  request field predicates
  """
  request: String
  requestNEQ: String
  requestIn: [String!]
  requestNotIn: [String!]
  requestGT: String
  requestGTE: String
  requestLT: String
  requestLTE: String
  requestContains: String
  requestHasPrefix: String
  requestHasSuffix: String
  requestEqualFold: String
  requestContainsFold: String
}
type OAuthRefreshToken implements Node {
  id: ID!
  signature: String!
  """
  information about the request
  """
  session: OAuthSession
}
"""
OAuthRefreshTokenWhereInput is used for filtering OAuthRefreshToken objects.
Input was generated by ent.
"""
input OAuthRefreshTokenWhereInput {
  not: OAuthRefreshTokenWhereInput
  and: [OAuthRefreshTokenWhereInput!]
  or: [OAuthRefreshTokenWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  signature field predicates
  """
  signature: String
  signatureNEQ: String
  signatureIn: [String!]
  signatureNotIn: [String!]
  signatureGT: String
  signatureGTE: String
  signatureLT: String
  signatureLTE: String
  signatureContains: String
  signatureHasPrefix: String
  signatureHasSuffix: String
  signatureEqualFold: String
  signatureContainsFold: String
  """
  session edge predicates
  """
  hasSession: Boolean
  hasSessionWith: [OAuthSessionWhereInput!]
}
type OAuthSession implements Node {
  id: ID!
  issuer: String!
  subject: String!
  audiences: [String!]!
  expiresAt: Time!
  issuedAt: Time!
  requestedAt: Time!
  authTime: Time!
  requestedScopes: [String!]!
  grantedScopes: [String!]!
  requestedAudiences: [String!]!
  grantedAudiences: [String!]!
  request: String!
  form: String!
}
"""
OAuthSessionWhereInput is used for filtering OAuthSession objects.
Input was generated by ent.
"""
input OAuthSessionWhereInput {
  not: OAuthSessionWhereInput
  and: [OAuthSessionWhereInput!]
  or: [OAuthSessionWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  issuer field predicates
  """
  issuer: String
  issuerNEQ: String
  issuerIn: [String!]
  issuerNotIn: [String!]
  issuerGT: String
  issuerGTE: String
  issuerLT: String
  issuerLTE: String
  issuerContains: String
  issuerHasPrefix: String
  issuerHasSuffix: String
  issuerEqualFold: String
  issuerContainsFold: String
  """
  subject field predicates
  """
  subject: String
  subjectNEQ: String
  subjectIn: [String!]
  subjectNotIn: [String!]
  subjectGT: String
  subjectGTE: String
  subjectLT: String
  subjectLTE: String
  subjectContains: String
  subjectHasPrefix: String
  subjectHasSuffix: String
  subjectEqualFold: String
  subjectContainsFold: String
  """
  expires_at field predicates
  """
  expiresAt: Time
  expiresAtNEQ: Time
  expiresAtIn: [Time!]
  expiresAtNotIn: [Time!]
  expiresAtGT: Time
  expiresAtGTE: Time
  expiresAtLT: Time
  expiresAtLTE: Time
  """
  issued_at field predicates
  """
  issuedAt: Time
  issuedAtNEQ: Time
  issuedAtIn: [Time!]
  issuedAtNotIn: [Time!]
  issuedAtGT: Time
  issuedAtGTE: Time
  issuedAtLT: Time
  issuedAtLTE: Time
  """
  requested_at field predicates
  """
  requestedAt: Time
  requestedAtNEQ: Time
  requestedAtIn: [Time!]
  requestedAtNotIn: [Time!]
  requestedAtGT: Time
  requestedAtGTE: Time
  requestedAtLT: Time
  requestedAtLTE: Time
  """
  auth_time field predicates
  """
  authTime: Time
  authTimeNEQ: Time
  authTimeIn: [Time!]
  authTimeNotIn: [Time!]
  authTimeGT: Time
  authTimeGTE: Time
  authTimeLT: Time
  authTimeLTE: Time
  """
  request field predicates
  """
  request: String
  requestNEQ: String
  requestIn: [String!]
  requestNotIn: [String!]
  requestGT: String
  requestGTE: String
  requestLT: String
  requestLTE: String
  requestContains: String
  requestHasPrefix: String
  requestHasSuffix: String
  requestEqualFold: String
  requestContainsFold: String
  """
  form field predicates
  """
  form: String
  formNEQ: String
  formIn: [String!]
  formNotIn: [String!]
  formGT: String
  formGTE: String
  formLT: String
  formLTE: String
  formContains: String
  formHasPrefix: String
  formHasSuffix: String
  formEqualFold: String
  formContainsFold: String
}
type OIDCAuthCode implements Node {
  id: ID!
  authorizationCode: String!
  """
  information about the request
  """
  session: OAuthSession
}
"""
OIDCAuthCodeWhereInput is used for filtering OIDCAuthCode objects.
Input was generated by ent.
"""
input OIDCAuthCodeWhereInput {
  not: OIDCAuthCodeWhereInput
  and: [OIDCAuthCodeWhereInput!]
  or: [OIDCAuthCodeWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  authorization_code field predicates
  """
  authorizationCode: String
  authorizationCodeNEQ: String
  authorizationCodeIn: [String!]
  authorizationCodeNotIn: [String!]
  authorizationCodeGT: String
  authorizationCodeGTE: String
  authorizationCodeLT: String
  authorizationCodeLTE: String
  authorizationCodeContains: String
  authorizationCodeHasPrefix: String
  authorizationCodeHasSuffix: String
  authorizationCodeEqualFold: String
  authorizationCodeContainsFold: String
  """
  session edge predicates
  """
  hasSession: Boolean
  hasSessionWith: [OAuthSessionWhereInput!]
}
"""
Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument.
"""
enum OrderDirection {
  """
  Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  ASC
  """
  Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  DESC
}
type PKCE implements Node {
  id: ID!
  code: String!
  """
  information about the request
  """
  session: OAuthSession
}
"""
PKCEWhereInput is used for filtering PKCE objects.
Input was generated by ent.
"""
input PKCEWhereInput {
  not: PKCEWhereInput
  and: [PKCEWhereInput!]
  or: [PKCEWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  code field predicates
  """
  code: String
  codeNEQ: String
  codeIn: [String!]
  codeNotIn: [String!]
  codeGT: String
  codeGTE: String
  codeLT: String
  codeLTE: String
  codeContains: String
  codeHasPrefix: String
  codeHasSuffix: String
  codeEqualFold: String
  codeContainsFold: String
  """
  session edge predicates
  """
  hasSession: Boolean
  hasSessionWith: [OAuthSessionWhereInput!]
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!
  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!
  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor
}
type PublicJWK implements Node {
  id: ID!
  sid: String!
  kid: String!
  key: String!
  issuer: String!
  scopes: [String!]!
}
type PublicJWKSet implements Node {
  id: ID!
}
"""
PublicJWKSetWhereInput is used for filtering PublicJWKSet objects.
Input was generated by ent.
"""
input PublicJWKSetWhereInput {
  not: PublicJWKSetWhereInput
  and: [PublicJWKSetWhereInput!]
  or: [PublicJWKSetWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
}
"""
PublicJWKWhereInput is used for filtering PublicJWK objects.
Input was generated by ent.
"""
input PublicJWKWhereInput {
  not: PublicJWKWhereInput
  and: [PublicJWKWhereInput!]
  or: [PublicJWKWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  sid field predicates
  """
  sid: String
  sidNEQ: String
  sidIn: [String!]
  sidNotIn: [String!]
  sidGT: String
  sidGTE: String
  sidLT: String
  sidLTE: String
  sidContains: String
  sidHasPrefix: String
  sidHasSuffix: String
  sidEqualFold: String
  sidContainsFold: String
  """
  kid field predicates
  """
  kid: String
  kidNEQ: String
  kidIn: [String!]
  kidNotIn: [String!]
  kidGT: String
  kidGTE: String
  kidLT: String
  kidLTE: String
  kidContains: String
  kidHasPrefix: String
  kidHasSuffix: String
  kidEqualFold: String
  kidContainsFold: String
  """
  key field predicates
  """
  key: String
  keyNEQ: String
  keyIn: [String!]
  keyNotIn: [String!]
  keyGT: String
  keyGTE: String
  keyLT: String
  keyLTE: String
  keyContains: String
  keyHasPrefix: String
  keyHasSuffix: String
  keyEqualFold: String
  keyContainsFold: String
  """
  issuer field predicates
  """
  issuer: String
  issuerNEQ: String
  issuerIn: [String!]
  issuerNotIn: [String!]
  issuerGT: String
  issuerGTE: String
  issuerLT: String
  issuerLTE: String
  issuerContains: String
  issuerHasPrefix: String
  issuerHasSuffix: String
  issuerEqualFold: String
  issuerContainsFold: String
}
type Query {
  """
  Fetches an object given its ID.
  """
  node(
    """
    ID of the object.
    """
    id: ID!
  ): Node
  """
  Lookup nodes by a list of IDs.
  """
  nodes(
    """
    The list of node IDs.
    """
    ids: [ID!]!
  ): [Node]!
  users: [User!]!
}
"""
UpdateUserInput is used for update User object.
Input was generated by ent.
"""
input UpdateUserInput {
  """
  The name displayed for the user
  """
  name: String
  """
  True if the user is active and able to authenticate
  """
  isactivated: Boolean
}
type User implements Node {
  id: ID!
  """
  The name displayed for the user
  """
  name: String!
  """
  True if the user is active and able to authenticate
  """
  isactivated: Boolean! @goField(name: "IsActivated", forceResolver: false)
}
"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
  not: UserWhereInput
  and: [UserWhereInput!]
  or: [UserWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  Name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  IsActivated field predicates
  """
  isactivated: Boolean
  isactivatedNEQ: Boolean
}
`, BuiltIn: false},
	{Name: "../schema/scalars.graphql", Input: `scalar Time`, BuiltIn: false},
	{Name: "../schema/mutation.graphql", Input: `type Mutation {
    requestCert(target: String!, pubKey: String!): String!
    revokeCert(serialNumber: String!): Boolean!
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
