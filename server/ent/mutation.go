// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/koalatea/authserver/server/ent/accessrequest"
	"github.com/koalatea/authserver/server/ent/oidcauthcode"
	"github.com/koalatea/authserver/server/ent/oidcclient"
	"github.com/koalatea/authserver/server/ent/oidcsession"
	"github.com/koalatea/authserver/server/ent/predicate"
	"github.com/koalatea/authserver/server/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccessRequest = "AccessRequest"
	TypeCert          = "Cert"
	TypeOIDCAuthCode  = "OIDCAuthCode"
	TypeOIDCClient    = "OIDCClient"
	TypeOIDCSession   = "OIDCSession"
	TypeUser          = "User"
)

// AccessRequestMutation represents an operation that mutates the AccessRequest nodes in the graph.
type AccessRequestMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	requested_scopes          *[]string
	appendrequested_scopes    []string
	granted_scopes            *[]string
	appendgranted_scopes      []string
	requested_audiences       *[]string
	appendrequested_audiences []string
	granted_audiences         *[]string
	appendgranted_audiences   []string
	request                   *string
	form                      *string
	active                    *bool
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*AccessRequest, error)
	predicates                []predicate.AccessRequest
}

var _ ent.Mutation = (*AccessRequestMutation)(nil)

// accessrequestOption allows management of the mutation configuration using functional options.
type accessrequestOption func(*AccessRequestMutation)

// newAccessRequestMutation creates new mutation for the AccessRequest entity.
func newAccessRequestMutation(c config, op Op, opts ...accessrequestOption) *AccessRequestMutation {
	m := &AccessRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeAccessRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccessRequestID sets the ID field of the mutation.
func withAccessRequestID(id int) accessrequestOption {
	return func(m *AccessRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *AccessRequest
		)
		m.oldValue = func(ctx context.Context) (*AccessRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccessRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccessRequest sets the old AccessRequest of the mutation.
func withAccessRequest(node *AccessRequest) accessrequestOption {
	return func(m *AccessRequestMutation) {
		m.oldValue = func(context.Context) (*AccessRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccessRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccessRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccessRequestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccessRequestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccessRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRequestedScopes sets the "requested_scopes" field.
func (m *AccessRequestMutation) SetRequestedScopes(s []string) {
	m.requested_scopes = &s
	m.appendrequested_scopes = nil
}

// RequestedScopes returns the value of the "requested_scopes" field in the mutation.
func (m *AccessRequestMutation) RequestedScopes() (r []string, exists bool) {
	v := m.requested_scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestedScopes returns the old "requested_scopes" field's value of the AccessRequest entity.
// If the AccessRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessRequestMutation) OldRequestedScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestedScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestedScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestedScopes: %w", err)
	}
	return oldValue.RequestedScopes, nil
}

// AppendRequestedScopes adds s to the "requested_scopes" field.
func (m *AccessRequestMutation) AppendRequestedScopes(s []string) {
	m.appendrequested_scopes = append(m.appendrequested_scopes, s...)
}

// AppendedRequestedScopes returns the list of values that were appended to the "requested_scopes" field in this mutation.
func (m *AccessRequestMutation) AppendedRequestedScopes() ([]string, bool) {
	if len(m.appendrequested_scopes) == 0 {
		return nil, false
	}
	return m.appendrequested_scopes, true
}

// ResetRequestedScopes resets all changes to the "requested_scopes" field.
func (m *AccessRequestMutation) ResetRequestedScopes() {
	m.requested_scopes = nil
	m.appendrequested_scopes = nil
}

// SetGrantedScopes sets the "granted_scopes" field.
func (m *AccessRequestMutation) SetGrantedScopes(s []string) {
	m.granted_scopes = &s
	m.appendgranted_scopes = nil
}

// GrantedScopes returns the value of the "granted_scopes" field in the mutation.
func (m *AccessRequestMutation) GrantedScopes() (r []string, exists bool) {
	v := m.granted_scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantedScopes returns the old "granted_scopes" field's value of the AccessRequest entity.
// If the AccessRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessRequestMutation) OldGrantedScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantedScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantedScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantedScopes: %w", err)
	}
	return oldValue.GrantedScopes, nil
}

// AppendGrantedScopes adds s to the "granted_scopes" field.
func (m *AccessRequestMutation) AppendGrantedScopes(s []string) {
	m.appendgranted_scopes = append(m.appendgranted_scopes, s...)
}

// AppendedGrantedScopes returns the list of values that were appended to the "granted_scopes" field in this mutation.
func (m *AccessRequestMutation) AppendedGrantedScopes() ([]string, bool) {
	if len(m.appendgranted_scopes) == 0 {
		return nil, false
	}
	return m.appendgranted_scopes, true
}

// ResetGrantedScopes resets all changes to the "granted_scopes" field.
func (m *AccessRequestMutation) ResetGrantedScopes() {
	m.granted_scopes = nil
	m.appendgranted_scopes = nil
}

// SetRequestedAudiences sets the "requested_audiences" field.
func (m *AccessRequestMutation) SetRequestedAudiences(s []string) {
	m.requested_audiences = &s
	m.appendrequested_audiences = nil
}

// RequestedAudiences returns the value of the "requested_audiences" field in the mutation.
func (m *AccessRequestMutation) RequestedAudiences() (r []string, exists bool) {
	v := m.requested_audiences
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestedAudiences returns the old "requested_audiences" field's value of the AccessRequest entity.
// If the AccessRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessRequestMutation) OldRequestedAudiences(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestedAudiences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestedAudiences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestedAudiences: %w", err)
	}
	return oldValue.RequestedAudiences, nil
}

// AppendRequestedAudiences adds s to the "requested_audiences" field.
func (m *AccessRequestMutation) AppendRequestedAudiences(s []string) {
	m.appendrequested_audiences = append(m.appendrequested_audiences, s...)
}

// AppendedRequestedAudiences returns the list of values that were appended to the "requested_audiences" field in this mutation.
func (m *AccessRequestMutation) AppendedRequestedAudiences() ([]string, bool) {
	if len(m.appendrequested_audiences) == 0 {
		return nil, false
	}
	return m.appendrequested_audiences, true
}

// ResetRequestedAudiences resets all changes to the "requested_audiences" field.
func (m *AccessRequestMutation) ResetRequestedAudiences() {
	m.requested_audiences = nil
	m.appendrequested_audiences = nil
}

// SetGrantedAudiences sets the "granted_audiences" field.
func (m *AccessRequestMutation) SetGrantedAudiences(s []string) {
	m.granted_audiences = &s
	m.appendgranted_audiences = nil
}

// GrantedAudiences returns the value of the "granted_audiences" field in the mutation.
func (m *AccessRequestMutation) GrantedAudiences() (r []string, exists bool) {
	v := m.granted_audiences
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantedAudiences returns the old "granted_audiences" field's value of the AccessRequest entity.
// If the AccessRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessRequestMutation) OldGrantedAudiences(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantedAudiences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantedAudiences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantedAudiences: %w", err)
	}
	return oldValue.GrantedAudiences, nil
}

// AppendGrantedAudiences adds s to the "granted_audiences" field.
func (m *AccessRequestMutation) AppendGrantedAudiences(s []string) {
	m.appendgranted_audiences = append(m.appendgranted_audiences, s...)
}

// AppendedGrantedAudiences returns the list of values that were appended to the "granted_audiences" field in this mutation.
func (m *AccessRequestMutation) AppendedGrantedAudiences() ([]string, bool) {
	if len(m.appendgranted_audiences) == 0 {
		return nil, false
	}
	return m.appendgranted_audiences, true
}

// ResetGrantedAudiences resets all changes to the "granted_audiences" field.
func (m *AccessRequestMutation) ResetGrantedAudiences() {
	m.granted_audiences = nil
	m.appendgranted_audiences = nil
}

// SetRequest sets the "request" field.
func (m *AccessRequestMutation) SetRequest(s string) {
	m.request = &s
}

// Request returns the value of the "request" field in the mutation.
func (m *AccessRequestMutation) Request() (r string, exists bool) {
	v := m.request
	if v == nil {
		return
	}
	return *v, true
}

// OldRequest returns the old "request" field's value of the AccessRequest entity.
// If the AccessRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessRequestMutation) OldRequest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequest: %w", err)
	}
	return oldValue.Request, nil
}

// ResetRequest resets all changes to the "request" field.
func (m *AccessRequestMutation) ResetRequest() {
	m.request = nil
}

// SetForm sets the "form" field.
func (m *AccessRequestMutation) SetForm(s string) {
	m.form = &s
}

// Form returns the value of the "form" field in the mutation.
func (m *AccessRequestMutation) Form() (r string, exists bool) {
	v := m.form
	if v == nil {
		return
	}
	return *v, true
}

// OldForm returns the old "form" field's value of the AccessRequest entity.
// If the AccessRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessRequestMutation) OldForm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForm: %w", err)
	}
	return oldValue.Form, nil
}

// ResetForm resets all changes to the "form" field.
func (m *AccessRequestMutation) ResetForm() {
	m.form = nil
}

// SetActive sets the "active" field.
func (m *AccessRequestMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *AccessRequestMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the AccessRequest entity.
// If the AccessRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessRequestMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *AccessRequestMutation) ResetActive() {
	m.active = nil
}

// Where appends a list predicates to the AccessRequestMutation builder.
func (m *AccessRequestMutation) Where(ps ...predicate.AccessRequest) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AccessRequestMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AccessRequest).
func (m *AccessRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccessRequestMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.requested_scopes != nil {
		fields = append(fields, accessrequest.FieldRequestedScopes)
	}
	if m.granted_scopes != nil {
		fields = append(fields, accessrequest.FieldGrantedScopes)
	}
	if m.requested_audiences != nil {
		fields = append(fields, accessrequest.FieldRequestedAudiences)
	}
	if m.granted_audiences != nil {
		fields = append(fields, accessrequest.FieldGrantedAudiences)
	}
	if m.request != nil {
		fields = append(fields, accessrequest.FieldRequest)
	}
	if m.form != nil {
		fields = append(fields, accessrequest.FieldForm)
	}
	if m.active != nil {
		fields = append(fields, accessrequest.FieldActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccessRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accessrequest.FieldRequestedScopes:
		return m.RequestedScopes()
	case accessrequest.FieldGrantedScopes:
		return m.GrantedScopes()
	case accessrequest.FieldRequestedAudiences:
		return m.RequestedAudiences()
	case accessrequest.FieldGrantedAudiences:
		return m.GrantedAudiences()
	case accessrequest.FieldRequest:
		return m.Request()
	case accessrequest.FieldForm:
		return m.Form()
	case accessrequest.FieldActive:
		return m.Active()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccessRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accessrequest.FieldRequestedScopes:
		return m.OldRequestedScopes(ctx)
	case accessrequest.FieldGrantedScopes:
		return m.OldGrantedScopes(ctx)
	case accessrequest.FieldRequestedAudiences:
		return m.OldRequestedAudiences(ctx)
	case accessrequest.FieldGrantedAudiences:
		return m.OldGrantedAudiences(ctx)
	case accessrequest.FieldRequest:
		return m.OldRequest(ctx)
	case accessrequest.FieldForm:
		return m.OldForm(ctx)
	case accessrequest.FieldActive:
		return m.OldActive(ctx)
	}
	return nil, fmt.Errorf("unknown AccessRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accessrequest.FieldRequestedScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestedScopes(v)
		return nil
	case accessrequest.FieldGrantedScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantedScopes(v)
		return nil
	case accessrequest.FieldRequestedAudiences:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestedAudiences(v)
		return nil
	case accessrequest.FieldGrantedAudiences:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantedAudiences(v)
		return nil
	case accessrequest.FieldRequest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequest(v)
		return nil
	case accessrequest.FieldForm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForm(v)
		return nil
	case accessrequest.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	}
	return fmt.Errorf("unknown AccessRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccessRequestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccessRequestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AccessRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccessRequestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccessRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccessRequestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccessRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccessRequestMutation) ResetField(name string) error {
	switch name {
	case accessrequest.FieldRequestedScopes:
		m.ResetRequestedScopes()
		return nil
	case accessrequest.FieldGrantedScopes:
		m.ResetGrantedScopes()
		return nil
	case accessrequest.FieldRequestedAudiences:
		m.ResetRequestedAudiences()
		return nil
	case accessrequest.FieldGrantedAudiences:
		m.ResetGrantedAudiences()
		return nil
	case accessrequest.FieldRequest:
		m.ResetRequest()
		return nil
	case accessrequest.FieldForm:
		m.ResetForm()
		return nil
	case accessrequest.FieldActive:
		m.ResetActive()
		return nil
	}
	return fmt.Errorf("unknown AccessRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccessRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccessRequestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccessRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccessRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccessRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccessRequestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccessRequestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AccessRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccessRequestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AccessRequest edge %s", name)
}

// CertMutation represents an operation that mutates the Cert nodes in the graph.
type CertMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Cert, error)
	predicates    []predicate.Cert
}

var _ ent.Mutation = (*CertMutation)(nil)

// certOption allows management of the mutation configuration using functional options.
type certOption func(*CertMutation)

// newCertMutation creates new mutation for the Cert entity.
func newCertMutation(c config, op Op, opts ...certOption) *CertMutation {
	m := &CertMutation{
		config:        c,
		op:            op,
		typ:           TypeCert,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertID sets the ID field of the mutation.
func withCertID(id int) certOption {
	return func(m *CertMutation) {
		var (
			err   error
			once  sync.Once
			value *Cert
		)
		m.oldValue = func(ctx context.Context) (*Cert, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cert.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCert sets the old Cert of the mutation.
func withCert(node *Cert) certOption {
	return func(m *CertMutation) {
		m.oldValue = func(context.Context) (*Cert, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cert.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the CertMutation builder.
func (m *CertMutation) Where(ps ...predicate.Cert) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CertMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cert).
func (m *CertMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Cert field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Cert field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Cert numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Cert nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Cert field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Cert unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Cert edge %s", name)
}

// OIDCAuthCodeMutation represents an operation that mutates the OIDCAuthCode nodes in the graph.
type OIDCAuthCodeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	authorization_code    *string
	clearedFields         map[string]struct{}
	access_request        *int
	clearedaccess_request bool
	session               *int
	clearedsession        bool
	done                  bool
	oldValue              func(context.Context) (*OIDCAuthCode, error)
	predicates            []predicate.OIDCAuthCode
}

var _ ent.Mutation = (*OIDCAuthCodeMutation)(nil)

// oidcauthcodeOption allows management of the mutation configuration using functional options.
type oidcauthcodeOption func(*OIDCAuthCodeMutation)

// newOIDCAuthCodeMutation creates new mutation for the OIDCAuthCode entity.
func newOIDCAuthCodeMutation(c config, op Op, opts ...oidcauthcodeOption) *OIDCAuthCodeMutation {
	m := &OIDCAuthCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeOIDCAuthCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOIDCAuthCodeID sets the ID field of the mutation.
func withOIDCAuthCodeID(id int) oidcauthcodeOption {
	return func(m *OIDCAuthCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *OIDCAuthCode
		)
		m.oldValue = func(ctx context.Context) (*OIDCAuthCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OIDCAuthCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOIDCAuthCode sets the old OIDCAuthCode of the mutation.
func withOIDCAuthCode(node *OIDCAuthCode) oidcauthcodeOption {
	return func(m *OIDCAuthCodeMutation) {
		m.oldValue = func(context.Context) (*OIDCAuthCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OIDCAuthCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OIDCAuthCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OIDCAuthCodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OIDCAuthCodeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OIDCAuthCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAuthorizationCode sets the "authorization_code" field.
func (m *OIDCAuthCodeMutation) SetAuthorizationCode(s string) {
	m.authorization_code = &s
}

// AuthorizationCode returns the value of the "authorization_code" field in the mutation.
func (m *OIDCAuthCodeMutation) AuthorizationCode() (r string, exists bool) {
	v := m.authorization_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorizationCode returns the old "authorization_code" field's value of the OIDCAuthCode entity.
// If the OIDCAuthCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OIDCAuthCodeMutation) OldAuthorizationCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorizationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorizationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorizationCode: %w", err)
	}
	return oldValue.AuthorizationCode, nil
}

// ResetAuthorizationCode resets all changes to the "authorization_code" field.
func (m *OIDCAuthCodeMutation) ResetAuthorizationCode() {
	m.authorization_code = nil
}

// SetAccessRequestID sets the "access_request" edge to the AccessRequest entity by id.
func (m *OIDCAuthCodeMutation) SetAccessRequestID(id int) {
	m.access_request = &id
}

// ClearAccessRequest clears the "access_request" edge to the AccessRequest entity.
func (m *OIDCAuthCodeMutation) ClearAccessRequest() {
	m.clearedaccess_request = true
}

// AccessRequestCleared reports if the "access_request" edge to the AccessRequest entity was cleared.
func (m *OIDCAuthCodeMutation) AccessRequestCleared() bool {
	return m.clearedaccess_request
}

// AccessRequestID returns the "access_request" edge ID in the mutation.
func (m *OIDCAuthCodeMutation) AccessRequestID() (id int, exists bool) {
	if m.access_request != nil {
		return *m.access_request, true
	}
	return
}

// AccessRequestIDs returns the "access_request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccessRequestID instead. It exists only for internal usage by the builders.
func (m *OIDCAuthCodeMutation) AccessRequestIDs() (ids []int) {
	if id := m.access_request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccessRequest resets all changes to the "access_request" edge.
func (m *OIDCAuthCodeMutation) ResetAccessRequest() {
	m.access_request = nil
	m.clearedaccess_request = false
}

// SetSessionID sets the "session" edge to the OIDCSession entity by id.
func (m *OIDCAuthCodeMutation) SetSessionID(id int) {
	m.session = &id
}

// ClearSession clears the "session" edge to the OIDCSession entity.
func (m *OIDCAuthCodeMutation) ClearSession() {
	m.clearedsession = true
}

// SessionCleared reports if the "session" edge to the OIDCSession entity was cleared.
func (m *OIDCAuthCodeMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionID returns the "session" edge ID in the mutation.
func (m *OIDCAuthCodeMutation) SessionID() (id int, exists bool) {
	if m.session != nil {
		return *m.session, true
	}
	return
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *OIDCAuthCodeMutation) SessionIDs() (ids []int) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *OIDCAuthCodeMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// Where appends a list predicates to the OIDCAuthCodeMutation builder.
func (m *OIDCAuthCodeMutation) Where(ps ...predicate.OIDCAuthCode) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OIDCAuthCodeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OIDCAuthCode).
func (m *OIDCAuthCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OIDCAuthCodeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.authorization_code != nil {
		fields = append(fields, oidcauthcode.FieldAuthorizationCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OIDCAuthCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oidcauthcode.FieldAuthorizationCode:
		return m.AuthorizationCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OIDCAuthCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oidcauthcode.FieldAuthorizationCode:
		return m.OldAuthorizationCode(ctx)
	}
	return nil, fmt.Errorf("unknown OIDCAuthCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OIDCAuthCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oidcauthcode.FieldAuthorizationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorizationCode(v)
		return nil
	}
	return fmt.Errorf("unknown OIDCAuthCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OIDCAuthCodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OIDCAuthCodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OIDCAuthCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OIDCAuthCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OIDCAuthCodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OIDCAuthCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OIDCAuthCodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OIDCAuthCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OIDCAuthCodeMutation) ResetField(name string) error {
	switch name {
	case oidcauthcode.FieldAuthorizationCode:
		m.ResetAuthorizationCode()
		return nil
	}
	return fmt.Errorf("unknown OIDCAuthCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OIDCAuthCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.access_request != nil {
		edges = append(edges, oidcauthcode.EdgeAccessRequest)
	}
	if m.session != nil {
		edges = append(edges, oidcauthcode.EdgeSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OIDCAuthCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oidcauthcode.EdgeAccessRequest:
		if id := m.access_request; id != nil {
			return []ent.Value{*id}
		}
	case oidcauthcode.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OIDCAuthCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OIDCAuthCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OIDCAuthCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccess_request {
		edges = append(edges, oidcauthcode.EdgeAccessRequest)
	}
	if m.clearedsession {
		edges = append(edges, oidcauthcode.EdgeSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OIDCAuthCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case oidcauthcode.EdgeAccessRequest:
		return m.clearedaccess_request
	case oidcauthcode.EdgeSession:
		return m.clearedsession
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OIDCAuthCodeMutation) ClearEdge(name string) error {
	switch name {
	case oidcauthcode.EdgeAccessRequest:
		m.ClearAccessRequest()
		return nil
	case oidcauthcode.EdgeSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown OIDCAuthCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OIDCAuthCodeMutation) ResetEdge(name string) error {
	switch name {
	case oidcauthcode.EdgeAccessRequest:
		m.ResetAccessRequest()
		return nil
	case oidcauthcode.EdgeSession:
		m.ResetSession()
		return nil
	}
	return fmt.Errorf("unknown OIDCAuthCode edge %s", name)
}

// OIDCClientMutation represents an operation that mutates the OIDCClient nodes in the graph.
type OIDCClientMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	client_id            *string
	secret               *string
	redirect_uris        *[]string
	appendredirect_uris  []string
	response_types       *[]string
	appendresponse_types []string
	grant_types          *[]string
	appendgrant_types    []string
	scopes               *[]string
	appendscopes         []string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*OIDCClient, error)
	predicates           []predicate.OIDCClient
}

var _ ent.Mutation = (*OIDCClientMutation)(nil)

// oidcclientOption allows management of the mutation configuration using functional options.
type oidcclientOption func(*OIDCClientMutation)

// newOIDCClientMutation creates new mutation for the OIDCClient entity.
func newOIDCClientMutation(c config, op Op, opts ...oidcclientOption) *OIDCClientMutation {
	m := &OIDCClientMutation{
		config:        c,
		op:            op,
		typ:           TypeOIDCClient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOIDCClientID sets the ID field of the mutation.
func withOIDCClientID(id int) oidcclientOption {
	return func(m *OIDCClientMutation) {
		var (
			err   error
			once  sync.Once
			value *OIDCClient
		)
		m.oldValue = func(ctx context.Context) (*OIDCClient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OIDCClient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOIDCClient sets the old OIDCClient of the mutation.
func withOIDCClient(node *OIDCClient) oidcclientOption {
	return func(m *OIDCClientMutation) {
		m.oldValue = func(context.Context) (*OIDCClient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OIDCClientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OIDCClientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OIDCClientMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OIDCClientMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OIDCClient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientID sets the "client_id" field.
func (m *OIDCClientMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *OIDCClientMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the OIDCClient entity.
// If the OIDCClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OIDCClientMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *OIDCClientMutation) ResetClientID() {
	m.client_id = nil
}

// SetSecret sets the "secret" field.
func (m *OIDCClientMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *OIDCClientMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the OIDCClient entity.
// If the OIDCClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OIDCClientMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *OIDCClientMutation) ResetSecret() {
	m.secret = nil
}

// SetRedirectUris sets the "redirect_uris" field.
func (m *OIDCClientMutation) SetRedirectUris(s []string) {
	m.redirect_uris = &s
	m.appendredirect_uris = nil
}

// RedirectUris returns the value of the "redirect_uris" field in the mutation.
func (m *OIDCClientMutation) RedirectUris() (r []string, exists bool) {
	v := m.redirect_uris
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectUris returns the old "redirect_uris" field's value of the OIDCClient entity.
// If the OIDCClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OIDCClientMutation) OldRedirectUris(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectUris is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectUris requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectUris: %w", err)
	}
	return oldValue.RedirectUris, nil
}

// AppendRedirectUris adds s to the "redirect_uris" field.
func (m *OIDCClientMutation) AppendRedirectUris(s []string) {
	m.appendredirect_uris = append(m.appendredirect_uris, s...)
}

// AppendedRedirectUris returns the list of values that were appended to the "redirect_uris" field in this mutation.
func (m *OIDCClientMutation) AppendedRedirectUris() ([]string, bool) {
	if len(m.appendredirect_uris) == 0 {
		return nil, false
	}
	return m.appendredirect_uris, true
}

// ResetRedirectUris resets all changes to the "redirect_uris" field.
func (m *OIDCClientMutation) ResetRedirectUris() {
	m.redirect_uris = nil
	m.appendredirect_uris = nil
}

// SetResponseTypes sets the "response_types" field.
func (m *OIDCClientMutation) SetResponseTypes(s []string) {
	m.response_types = &s
	m.appendresponse_types = nil
}

// ResponseTypes returns the value of the "response_types" field in the mutation.
func (m *OIDCClientMutation) ResponseTypes() (r []string, exists bool) {
	v := m.response_types
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseTypes returns the old "response_types" field's value of the OIDCClient entity.
// If the OIDCClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OIDCClientMutation) OldResponseTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseTypes: %w", err)
	}
	return oldValue.ResponseTypes, nil
}

// AppendResponseTypes adds s to the "response_types" field.
func (m *OIDCClientMutation) AppendResponseTypes(s []string) {
	m.appendresponse_types = append(m.appendresponse_types, s...)
}

// AppendedResponseTypes returns the list of values that were appended to the "response_types" field in this mutation.
func (m *OIDCClientMutation) AppendedResponseTypes() ([]string, bool) {
	if len(m.appendresponse_types) == 0 {
		return nil, false
	}
	return m.appendresponse_types, true
}

// ResetResponseTypes resets all changes to the "response_types" field.
func (m *OIDCClientMutation) ResetResponseTypes() {
	m.response_types = nil
	m.appendresponse_types = nil
}

// SetGrantTypes sets the "grant_types" field.
func (m *OIDCClientMutation) SetGrantTypes(s []string) {
	m.grant_types = &s
	m.appendgrant_types = nil
}

// GrantTypes returns the value of the "grant_types" field in the mutation.
func (m *OIDCClientMutation) GrantTypes() (r []string, exists bool) {
	v := m.grant_types
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantTypes returns the old "grant_types" field's value of the OIDCClient entity.
// If the OIDCClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OIDCClientMutation) OldGrantTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantTypes: %w", err)
	}
	return oldValue.GrantTypes, nil
}

// AppendGrantTypes adds s to the "grant_types" field.
func (m *OIDCClientMutation) AppendGrantTypes(s []string) {
	m.appendgrant_types = append(m.appendgrant_types, s...)
}

// AppendedGrantTypes returns the list of values that were appended to the "grant_types" field in this mutation.
func (m *OIDCClientMutation) AppendedGrantTypes() ([]string, bool) {
	if len(m.appendgrant_types) == 0 {
		return nil, false
	}
	return m.appendgrant_types, true
}

// ResetGrantTypes resets all changes to the "grant_types" field.
func (m *OIDCClientMutation) ResetGrantTypes() {
	m.grant_types = nil
	m.appendgrant_types = nil
}

// SetScopes sets the "scopes" field.
func (m *OIDCClientMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *OIDCClientMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the OIDCClient entity.
// If the OIDCClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OIDCClientMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *OIDCClientMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *OIDCClientMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ResetScopes resets all changes to the "scopes" field.
func (m *OIDCClientMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
}

// Where appends a list predicates to the OIDCClientMutation builder.
func (m *OIDCClientMutation) Where(ps ...predicate.OIDCClient) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OIDCClientMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OIDCClient).
func (m *OIDCClientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OIDCClientMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.client_id != nil {
		fields = append(fields, oidcclient.FieldClientID)
	}
	if m.secret != nil {
		fields = append(fields, oidcclient.FieldSecret)
	}
	if m.redirect_uris != nil {
		fields = append(fields, oidcclient.FieldRedirectUris)
	}
	if m.response_types != nil {
		fields = append(fields, oidcclient.FieldResponseTypes)
	}
	if m.grant_types != nil {
		fields = append(fields, oidcclient.FieldGrantTypes)
	}
	if m.scopes != nil {
		fields = append(fields, oidcclient.FieldScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OIDCClientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oidcclient.FieldClientID:
		return m.ClientID()
	case oidcclient.FieldSecret:
		return m.Secret()
	case oidcclient.FieldRedirectUris:
		return m.RedirectUris()
	case oidcclient.FieldResponseTypes:
		return m.ResponseTypes()
	case oidcclient.FieldGrantTypes:
		return m.GrantTypes()
	case oidcclient.FieldScopes:
		return m.Scopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OIDCClientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oidcclient.FieldClientID:
		return m.OldClientID(ctx)
	case oidcclient.FieldSecret:
		return m.OldSecret(ctx)
	case oidcclient.FieldRedirectUris:
		return m.OldRedirectUris(ctx)
	case oidcclient.FieldResponseTypes:
		return m.OldResponseTypes(ctx)
	case oidcclient.FieldGrantTypes:
		return m.OldGrantTypes(ctx)
	case oidcclient.FieldScopes:
		return m.OldScopes(ctx)
	}
	return nil, fmt.Errorf("unknown OIDCClient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OIDCClientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oidcclient.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case oidcclient.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case oidcclient.FieldRedirectUris:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectUris(v)
		return nil
	case oidcclient.FieldResponseTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseTypes(v)
		return nil
	case oidcclient.FieldGrantTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantTypes(v)
		return nil
	case oidcclient.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	}
	return fmt.Errorf("unknown OIDCClient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OIDCClientMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OIDCClientMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OIDCClientMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OIDCClient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OIDCClientMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OIDCClientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OIDCClientMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OIDCClient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OIDCClientMutation) ResetField(name string) error {
	switch name {
	case oidcclient.FieldClientID:
		m.ResetClientID()
		return nil
	case oidcclient.FieldSecret:
		m.ResetSecret()
		return nil
	case oidcclient.FieldRedirectUris:
		m.ResetRedirectUris()
		return nil
	case oidcclient.FieldResponseTypes:
		m.ResetResponseTypes()
		return nil
	case oidcclient.FieldGrantTypes:
		m.ResetGrantTypes()
		return nil
	case oidcclient.FieldScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown OIDCClient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OIDCClientMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OIDCClientMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OIDCClientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OIDCClientMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OIDCClientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OIDCClientMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OIDCClientMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OIDCClient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OIDCClientMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OIDCClient edge %s", name)
}

// OIDCSessionMutation represents an operation that mutates the OIDCSession nodes in the graph.
type OIDCSessionMutation struct {
	config
	op              Op
	typ             string
	id              *int
	issuer          *string
	subject         *string
	audiences       *[]string
	appendaudiences []string
	expires_at      *time.Time
	issued_at       *time.Time
	requested_at    *time.Time
	auth_time       *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*OIDCSession, error)
	predicates      []predicate.OIDCSession
}

var _ ent.Mutation = (*OIDCSessionMutation)(nil)

// oidcsessionOption allows management of the mutation configuration using functional options.
type oidcsessionOption func(*OIDCSessionMutation)

// newOIDCSessionMutation creates new mutation for the OIDCSession entity.
func newOIDCSessionMutation(c config, op Op, opts ...oidcsessionOption) *OIDCSessionMutation {
	m := &OIDCSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeOIDCSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOIDCSessionID sets the ID field of the mutation.
func withOIDCSessionID(id int) oidcsessionOption {
	return func(m *OIDCSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *OIDCSession
		)
		m.oldValue = func(ctx context.Context) (*OIDCSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OIDCSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOIDCSession sets the old OIDCSession of the mutation.
func withOIDCSession(node *OIDCSession) oidcsessionOption {
	return func(m *OIDCSessionMutation) {
		m.oldValue = func(context.Context) (*OIDCSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OIDCSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OIDCSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OIDCSessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OIDCSessionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OIDCSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIssuer sets the "issuer" field.
func (m *OIDCSessionMutation) SetIssuer(s string) {
	m.issuer = &s
}

// Issuer returns the value of the "issuer" field in the mutation.
func (m *OIDCSessionMutation) Issuer() (r string, exists bool) {
	v := m.issuer
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuer returns the old "issuer" field's value of the OIDCSession entity.
// If the OIDCSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OIDCSessionMutation) OldIssuer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuer: %w", err)
	}
	return oldValue.Issuer, nil
}

// ResetIssuer resets all changes to the "issuer" field.
func (m *OIDCSessionMutation) ResetIssuer() {
	m.issuer = nil
}

// SetSubject sets the "subject" field.
func (m *OIDCSessionMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *OIDCSessionMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the OIDCSession entity.
// If the OIDCSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OIDCSessionMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *OIDCSessionMutation) ResetSubject() {
	m.subject = nil
}

// SetAudiences sets the "audiences" field.
func (m *OIDCSessionMutation) SetAudiences(s []string) {
	m.audiences = &s
	m.appendaudiences = nil
}

// Audiences returns the value of the "audiences" field in the mutation.
func (m *OIDCSessionMutation) Audiences() (r []string, exists bool) {
	v := m.audiences
	if v == nil {
		return
	}
	return *v, true
}

// OldAudiences returns the old "audiences" field's value of the OIDCSession entity.
// If the OIDCSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OIDCSessionMutation) OldAudiences(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAudiences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAudiences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAudiences: %w", err)
	}
	return oldValue.Audiences, nil
}

// AppendAudiences adds s to the "audiences" field.
func (m *OIDCSessionMutation) AppendAudiences(s []string) {
	m.appendaudiences = append(m.appendaudiences, s...)
}

// AppendedAudiences returns the list of values that were appended to the "audiences" field in this mutation.
func (m *OIDCSessionMutation) AppendedAudiences() ([]string, bool) {
	if len(m.appendaudiences) == 0 {
		return nil, false
	}
	return m.appendaudiences, true
}

// ResetAudiences resets all changes to the "audiences" field.
func (m *OIDCSessionMutation) ResetAudiences() {
	m.audiences = nil
	m.appendaudiences = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *OIDCSessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *OIDCSessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the OIDCSession entity.
// If the OIDCSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OIDCSessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *OIDCSessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetIssuedAt sets the "issued_at" field.
func (m *OIDCSessionMutation) SetIssuedAt(t time.Time) {
	m.issued_at = &t
}

// IssuedAt returns the value of the "issued_at" field in the mutation.
func (m *OIDCSessionMutation) IssuedAt() (r time.Time, exists bool) {
	v := m.issued_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuedAt returns the old "issued_at" field's value of the OIDCSession entity.
// If the OIDCSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OIDCSessionMutation) OldIssuedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuedAt: %w", err)
	}
	return oldValue.IssuedAt, nil
}

// ResetIssuedAt resets all changes to the "issued_at" field.
func (m *OIDCSessionMutation) ResetIssuedAt() {
	m.issued_at = nil
}

// SetRequestedAt sets the "requested_at" field.
func (m *OIDCSessionMutation) SetRequestedAt(t time.Time) {
	m.requested_at = &t
}

// RequestedAt returns the value of the "requested_at" field in the mutation.
func (m *OIDCSessionMutation) RequestedAt() (r time.Time, exists bool) {
	v := m.requested_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestedAt returns the old "requested_at" field's value of the OIDCSession entity.
// If the OIDCSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OIDCSessionMutation) OldRequestedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestedAt: %w", err)
	}
	return oldValue.RequestedAt, nil
}

// ResetRequestedAt resets all changes to the "requested_at" field.
func (m *OIDCSessionMutation) ResetRequestedAt() {
	m.requested_at = nil
}

// SetAuthTime sets the "auth_time" field.
func (m *OIDCSessionMutation) SetAuthTime(t time.Time) {
	m.auth_time = &t
}

// AuthTime returns the value of the "auth_time" field in the mutation.
func (m *OIDCSessionMutation) AuthTime() (r time.Time, exists bool) {
	v := m.auth_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthTime returns the old "auth_time" field's value of the OIDCSession entity.
// If the OIDCSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OIDCSessionMutation) OldAuthTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthTime: %w", err)
	}
	return oldValue.AuthTime, nil
}

// ResetAuthTime resets all changes to the "auth_time" field.
func (m *OIDCSessionMutation) ResetAuthTime() {
	m.auth_time = nil
}

// Where appends a list predicates to the OIDCSessionMutation builder.
func (m *OIDCSessionMutation) Where(ps ...predicate.OIDCSession) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OIDCSessionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OIDCSession).
func (m *OIDCSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OIDCSessionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.issuer != nil {
		fields = append(fields, oidcsession.FieldIssuer)
	}
	if m.subject != nil {
		fields = append(fields, oidcsession.FieldSubject)
	}
	if m.audiences != nil {
		fields = append(fields, oidcsession.FieldAudiences)
	}
	if m.expires_at != nil {
		fields = append(fields, oidcsession.FieldExpiresAt)
	}
	if m.issued_at != nil {
		fields = append(fields, oidcsession.FieldIssuedAt)
	}
	if m.requested_at != nil {
		fields = append(fields, oidcsession.FieldRequestedAt)
	}
	if m.auth_time != nil {
		fields = append(fields, oidcsession.FieldAuthTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OIDCSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oidcsession.FieldIssuer:
		return m.Issuer()
	case oidcsession.FieldSubject:
		return m.Subject()
	case oidcsession.FieldAudiences:
		return m.Audiences()
	case oidcsession.FieldExpiresAt:
		return m.ExpiresAt()
	case oidcsession.FieldIssuedAt:
		return m.IssuedAt()
	case oidcsession.FieldRequestedAt:
		return m.RequestedAt()
	case oidcsession.FieldAuthTime:
		return m.AuthTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OIDCSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oidcsession.FieldIssuer:
		return m.OldIssuer(ctx)
	case oidcsession.FieldSubject:
		return m.OldSubject(ctx)
	case oidcsession.FieldAudiences:
		return m.OldAudiences(ctx)
	case oidcsession.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case oidcsession.FieldIssuedAt:
		return m.OldIssuedAt(ctx)
	case oidcsession.FieldRequestedAt:
		return m.OldRequestedAt(ctx)
	case oidcsession.FieldAuthTime:
		return m.OldAuthTime(ctx)
	}
	return nil, fmt.Errorf("unknown OIDCSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OIDCSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oidcsession.FieldIssuer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuer(v)
		return nil
	case oidcsession.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case oidcsession.FieldAudiences:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAudiences(v)
		return nil
	case oidcsession.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case oidcsession.FieldIssuedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuedAt(v)
		return nil
	case oidcsession.FieldRequestedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestedAt(v)
		return nil
	case oidcsession.FieldAuthTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthTime(v)
		return nil
	}
	return fmt.Errorf("unknown OIDCSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OIDCSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OIDCSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OIDCSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OIDCSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OIDCSessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OIDCSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OIDCSessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OIDCSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OIDCSessionMutation) ResetField(name string) error {
	switch name {
	case oidcsession.FieldIssuer:
		m.ResetIssuer()
		return nil
	case oidcsession.FieldSubject:
		m.ResetSubject()
		return nil
	case oidcsession.FieldAudiences:
		m.ResetAudiences()
		return nil
	case oidcsession.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case oidcsession.FieldIssuedAt:
		m.ResetIssuedAt()
		return nil
	case oidcsession.FieldRequestedAt:
		m.ResetRequestedAt()
		return nil
	case oidcsession.FieldAuthTime:
		m.ResetAuthTime()
		return nil
	}
	return fmt.Errorf("unknown OIDCSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OIDCSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OIDCSessionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OIDCSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OIDCSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OIDCSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OIDCSessionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OIDCSessionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OIDCSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OIDCSessionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OIDCSession edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Name         *string
	_OAuthID      *string
	_SessionToken *string
	_IsActivated  *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *UserMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *UserMutation) ResetName() {
	m._Name = nil
}

// SetOAuthID sets the "OAuthID" field.
func (m *UserMutation) SetOAuthID(s string) {
	m._OAuthID = &s
}

// OAuthID returns the value of the "OAuthID" field in the mutation.
func (m *UserMutation) OAuthID() (r string, exists bool) {
	v := m._OAuthID
	if v == nil {
		return
	}
	return *v, true
}

// OldOAuthID returns the old "OAuthID" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOAuthID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOAuthID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOAuthID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOAuthID: %w", err)
	}
	return oldValue.OAuthID, nil
}

// ResetOAuthID resets all changes to the "OAuthID" field.
func (m *UserMutation) ResetOAuthID() {
	m._OAuthID = nil
}

// SetSessionToken sets the "SessionToken" field.
func (m *UserMutation) SetSessionToken(s string) {
	m._SessionToken = &s
}

// SessionToken returns the value of the "SessionToken" field in the mutation.
func (m *UserMutation) SessionToken() (r string, exists bool) {
	v := m._SessionToken
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionToken returns the old "SessionToken" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSessionToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionToken: %w", err)
	}
	return oldValue.SessionToken, nil
}

// ResetSessionToken resets all changes to the "SessionToken" field.
func (m *UserMutation) ResetSessionToken() {
	m._SessionToken = nil
}

// SetIsActivated sets the "IsActivated" field.
func (m *UserMutation) SetIsActivated(b bool) {
	m._IsActivated = &b
}

// IsActivated returns the value of the "IsActivated" field in the mutation.
func (m *UserMutation) IsActivated() (r bool, exists bool) {
	v := m._IsActivated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActivated returns the old "IsActivated" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsActivated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActivated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActivated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActivated: %w", err)
	}
	return oldValue.IsActivated, nil
}

// ResetIsActivated resets all changes to the "IsActivated" field.
func (m *UserMutation) ResetIsActivated() {
	m._IsActivated = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._Name != nil {
		fields = append(fields, user.FieldName)
	}
	if m._OAuthID != nil {
		fields = append(fields, user.FieldOAuthID)
	}
	if m._SessionToken != nil {
		fields = append(fields, user.FieldSessionToken)
	}
	if m._IsActivated != nil {
		fields = append(fields, user.FieldIsActivated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldOAuthID:
		return m.OAuthID()
	case user.FieldSessionToken:
		return m.SessionToken()
	case user.FieldIsActivated:
		return m.IsActivated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldOAuthID:
		return m.OldOAuthID(ctx)
	case user.FieldSessionToken:
		return m.OldSessionToken(ctx)
	case user.FieldIsActivated:
		return m.OldIsActivated(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldOAuthID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOAuthID(v)
		return nil
	case user.FieldSessionToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionToken(v)
		return nil
	case user.FieldIsActivated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActivated(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldOAuthID:
		m.ResetOAuthID()
		return nil
	case user.FieldSessionToken:
		m.ResetSessionToken()
		return nil
	case user.FieldIsActivated:
		m.ResetIsActivated()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
