// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/koalatea/authserver/server/ent/authcode"
	"github.com/koalatea/authserver/server/ent/cert"
	"github.com/koalatea/authserver/server/ent/denylistedjti"
	"github.com/koalatea/authserver/server/ent/oauthaccesstoken"
	"github.com/koalatea/authserver/server/ent/oauthclient"
	"github.com/koalatea/authserver/server/ent/oauthparrequest"
	"github.com/koalatea/authserver/server/ent/oauthrefreshtoken"
	"github.com/koalatea/authserver/server/ent/oauthsession"
	"github.com/koalatea/authserver/server/ent/oidcauthcode"
	"github.com/koalatea/authserver/server/ent/pkce"
	"github.com/koalatea/authserver/server/ent/predicate"
	"github.com/koalatea/authserver/server/ent/publicjwk"
	"github.com/koalatea/authserver/server/ent/publicjwkset"
	"github.com/koalatea/authserver/server/ent/user"
)

// AuthCodeWhereInput represents a where input for filtering AuthCode queries.
type AuthCodeWhereInput struct {
	Predicates []predicate.AuthCode  `json:"-"`
	Not        *AuthCodeWhereInput   `json:"not,omitempty"`
	Or         []*AuthCodeWhereInput `json:"or,omitempty"`
	And        []*AuthCodeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "session" edge predicates.
	HasSession     *bool                     `json:"hasSession,omitempty"`
	HasSessionWith []*OAuthSessionWhereInput `json:"hasSessionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AuthCodeWhereInput) AddPredicates(predicates ...predicate.AuthCode) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AuthCodeWhereInput filter on the AuthCodeQuery builder.
func (i *AuthCodeWhereInput) Filter(q *AuthCodeQuery) (*AuthCodeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAuthCodeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAuthCodeWhereInput is returned in case the AuthCodeWhereInput is empty.
var ErrEmptyAuthCodeWhereInput = errors.New("ent: empty predicate AuthCodeWhereInput")

// P returns a predicate for filtering authcodes.
// An error is returned if the input is empty or invalid.
func (i *AuthCodeWhereInput) P() (predicate.AuthCode, error) {
	var predicates []predicate.AuthCode
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, authcode.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AuthCode, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, authcode.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AuthCode, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, authcode.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, authcode.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, authcode.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, authcode.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, authcode.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, authcode.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, authcode.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, authcode.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, authcode.IDLTE(*i.IDLTE))
	}
	if i.Code != nil {
		predicates = append(predicates, authcode.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, authcode.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, authcode.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, authcode.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, authcode.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, authcode.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, authcode.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, authcode.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, authcode.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, authcode.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, authcode.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, authcode.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, authcode.CodeContainsFold(*i.CodeContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, authcode.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, authcode.ActiveNEQ(*i.ActiveNEQ))
	}

	if i.HasSession != nil {
		p := authcode.HasSession()
		if !*i.HasSession {
			p = authcode.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSessionWith) > 0 {
		with := make([]predicate.OAuthSession, 0, len(i.HasSessionWith))
		for _, w := range i.HasSessionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSessionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, authcode.HasSessionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAuthCodeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return authcode.And(predicates...), nil
	}
}

// CertWhereInput represents a where input for filtering Cert queries.
type CertWhereInput struct {
	Predicates []predicate.Cert  `json:"-"`
	Not        *CertWhereInput   `json:"not,omitempty"`
	Or         []*CertWhereInput `json:"or,omitempty"`
	And        []*CertWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CertWhereInput) AddPredicates(predicates ...predicate.Cert) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CertWhereInput filter on the CertQuery builder.
func (i *CertWhereInput) Filter(q *CertQuery) (*CertQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCertWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCertWhereInput is returned in case the CertWhereInput is empty.
var ErrEmptyCertWhereInput = errors.New("ent: empty predicate CertWhereInput")

// P returns a predicate for filtering certs.
// An error is returned if the input is empty or invalid.
func (i *CertWhereInput) P() (predicate.Cert, error) {
	var predicates []predicate.Cert
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, cert.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Cert, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, cert.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Cert, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, cert.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, cert.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, cert.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, cert.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, cert.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, cert.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, cert.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, cert.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, cert.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCertWhereInput
	case 1:
		return predicates[0], nil
	default:
		return cert.And(predicates...), nil
	}
}

// DenyListedJTIWhereInput represents a where input for filtering DenyListedJTI queries.
type DenyListedJTIWhereInput struct {
	Predicates []predicate.DenyListedJTI  `json:"-"`
	Not        *DenyListedJTIWhereInput   `json:"not,omitempty"`
	Or         []*DenyListedJTIWhereInput `json:"or,omitempty"`
	And        []*DenyListedJTIWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "jti" field predicates.
	Jti             *string  `json:"jti,omitempty"`
	JtiNEQ          *string  `json:"jtiNEQ,omitempty"`
	JtiIn           []string `json:"jtiIn,omitempty"`
	JtiNotIn        []string `json:"jtiNotIn,omitempty"`
	JtiGT           *string  `json:"jtiGT,omitempty"`
	JtiGTE          *string  `json:"jtiGTE,omitempty"`
	JtiLT           *string  `json:"jtiLT,omitempty"`
	JtiLTE          *string  `json:"jtiLTE,omitempty"`
	JtiContains     *string  `json:"jtiContains,omitempty"`
	JtiHasPrefix    *string  `json:"jtiHasPrefix,omitempty"`
	JtiHasSuffix    *string  `json:"jtiHasSuffix,omitempty"`
	JtiEqualFold    *string  `json:"jtiEqualFold,omitempty"`
	JtiContainsFold *string  `json:"jtiContainsFold,omitempty"`

	// "expiration" field predicates.
	Expiration      *time.Time  `json:"expiration,omitempty"`
	ExpirationNEQ   *time.Time  `json:"expirationNEQ,omitempty"`
	ExpirationIn    []time.Time `json:"expirationIn,omitempty"`
	ExpirationNotIn []time.Time `json:"expirationNotIn,omitempty"`
	ExpirationGT    *time.Time  `json:"expirationGT,omitempty"`
	ExpirationGTE   *time.Time  `json:"expirationGTE,omitempty"`
	ExpirationLT    *time.Time  `json:"expirationLT,omitempty"`
	ExpirationLTE   *time.Time  `json:"expirationLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DenyListedJTIWhereInput) AddPredicates(predicates ...predicate.DenyListedJTI) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DenyListedJTIWhereInput filter on the DenyListedJTIQuery builder.
func (i *DenyListedJTIWhereInput) Filter(q *DenyListedJTIQuery) (*DenyListedJTIQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDenyListedJTIWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDenyListedJTIWhereInput is returned in case the DenyListedJTIWhereInput is empty.
var ErrEmptyDenyListedJTIWhereInput = errors.New("ent: empty predicate DenyListedJTIWhereInput")

// P returns a predicate for filtering denylistedjtis.
// An error is returned if the input is empty or invalid.
func (i *DenyListedJTIWhereInput) P() (predicate.DenyListedJTI, error) {
	var predicates []predicate.DenyListedJTI
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, denylistedjti.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DenyListedJTI, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, denylistedjti.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DenyListedJTI, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, denylistedjti.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, denylistedjti.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, denylistedjti.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, denylistedjti.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, denylistedjti.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, denylistedjti.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, denylistedjti.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, denylistedjti.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, denylistedjti.IDLTE(*i.IDLTE))
	}
	if i.Jti != nil {
		predicates = append(predicates, denylistedjti.JtiEQ(*i.Jti))
	}
	if i.JtiNEQ != nil {
		predicates = append(predicates, denylistedjti.JtiNEQ(*i.JtiNEQ))
	}
	if len(i.JtiIn) > 0 {
		predicates = append(predicates, denylistedjti.JtiIn(i.JtiIn...))
	}
	if len(i.JtiNotIn) > 0 {
		predicates = append(predicates, denylistedjti.JtiNotIn(i.JtiNotIn...))
	}
	if i.JtiGT != nil {
		predicates = append(predicates, denylistedjti.JtiGT(*i.JtiGT))
	}
	if i.JtiGTE != nil {
		predicates = append(predicates, denylistedjti.JtiGTE(*i.JtiGTE))
	}
	if i.JtiLT != nil {
		predicates = append(predicates, denylistedjti.JtiLT(*i.JtiLT))
	}
	if i.JtiLTE != nil {
		predicates = append(predicates, denylistedjti.JtiLTE(*i.JtiLTE))
	}
	if i.JtiContains != nil {
		predicates = append(predicates, denylistedjti.JtiContains(*i.JtiContains))
	}
	if i.JtiHasPrefix != nil {
		predicates = append(predicates, denylistedjti.JtiHasPrefix(*i.JtiHasPrefix))
	}
	if i.JtiHasSuffix != nil {
		predicates = append(predicates, denylistedjti.JtiHasSuffix(*i.JtiHasSuffix))
	}
	if i.JtiEqualFold != nil {
		predicates = append(predicates, denylistedjti.JtiEqualFold(*i.JtiEqualFold))
	}
	if i.JtiContainsFold != nil {
		predicates = append(predicates, denylistedjti.JtiContainsFold(*i.JtiContainsFold))
	}
	if i.Expiration != nil {
		predicates = append(predicates, denylistedjti.ExpirationEQ(*i.Expiration))
	}
	if i.ExpirationNEQ != nil {
		predicates = append(predicates, denylistedjti.ExpirationNEQ(*i.ExpirationNEQ))
	}
	if len(i.ExpirationIn) > 0 {
		predicates = append(predicates, denylistedjti.ExpirationIn(i.ExpirationIn...))
	}
	if len(i.ExpirationNotIn) > 0 {
		predicates = append(predicates, denylistedjti.ExpirationNotIn(i.ExpirationNotIn...))
	}
	if i.ExpirationGT != nil {
		predicates = append(predicates, denylistedjti.ExpirationGT(*i.ExpirationGT))
	}
	if i.ExpirationGTE != nil {
		predicates = append(predicates, denylistedjti.ExpirationGTE(*i.ExpirationGTE))
	}
	if i.ExpirationLT != nil {
		predicates = append(predicates, denylistedjti.ExpirationLT(*i.ExpirationLT))
	}
	if i.ExpirationLTE != nil {
		predicates = append(predicates, denylistedjti.ExpirationLTE(*i.ExpirationLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDenyListedJTIWhereInput
	case 1:
		return predicates[0], nil
	default:
		return denylistedjti.And(predicates...), nil
	}
}

// OAuthAccessTokenWhereInput represents a where input for filtering OAuthAccessToken queries.
type OAuthAccessTokenWhereInput struct {
	Predicates []predicate.OAuthAccessToken  `json:"-"`
	Not        *OAuthAccessTokenWhereInput   `json:"not,omitempty"`
	Or         []*OAuthAccessTokenWhereInput `json:"or,omitempty"`
	And        []*OAuthAccessTokenWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "signature" field predicates.
	Signature             *string  `json:"signature,omitempty"`
	SignatureNEQ          *string  `json:"signatureNEQ,omitempty"`
	SignatureIn           []string `json:"signatureIn,omitempty"`
	SignatureNotIn        []string `json:"signatureNotIn,omitempty"`
	SignatureGT           *string  `json:"signatureGT,omitempty"`
	SignatureGTE          *string  `json:"signatureGTE,omitempty"`
	SignatureLT           *string  `json:"signatureLT,omitempty"`
	SignatureLTE          *string  `json:"signatureLTE,omitempty"`
	SignatureContains     *string  `json:"signatureContains,omitempty"`
	SignatureHasPrefix    *string  `json:"signatureHasPrefix,omitempty"`
	SignatureHasSuffix    *string  `json:"signatureHasSuffix,omitempty"`
	SignatureEqualFold    *string  `json:"signatureEqualFold,omitempty"`
	SignatureContainsFold *string  `json:"signatureContainsFold,omitempty"`

	// "session" edge predicates.
	HasSession     *bool                     `json:"hasSession,omitempty"`
	HasSessionWith []*OAuthSessionWhereInput `json:"hasSessionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OAuthAccessTokenWhereInput) AddPredicates(predicates ...predicate.OAuthAccessToken) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OAuthAccessTokenWhereInput filter on the OAuthAccessTokenQuery builder.
func (i *OAuthAccessTokenWhereInput) Filter(q *OAuthAccessTokenQuery) (*OAuthAccessTokenQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOAuthAccessTokenWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOAuthAccessTokenWhereInput is returned in case the OAuthAccessTokenWhereInput is empty.
var ErrEmptyOAuthAccessTokenWhereInput = errors.New("ent: empty predicate OAuthAccessTokenWhereInput")

// P returns a predicate for filtering oauthaccesstokens.
// An error is returned if the input is empty or invalid.
func (i *OAuthAccessTokenWhereInput) P() (predicate.OAuthAccessToken, error) {
	var predicates []predicate.OAuthAccessToken
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, oauthaccesstoken.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OAuthAccessToken, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, oauthaccesstoken.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OAuthAccessToken, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, oauthaccesstoken.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, oauthaccesstoken.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, oauthaccesstoken.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, oauthaccesstoken.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, oauthaccesstoken.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, oauthaccesstoken.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, oauthaccesstoken.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, oauthaccesstoken.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, oauthaccesstoken.IDLTE(*i.IDLTE))
	}
	if i.Signature != nil {
		predicates = append(predicates, oauthaccesstoken.SignatureEQ(*i.Signature))
	}
	if i.SignatureNEQ != nil {
		predicates = append(predicates, oauthaccesstoken.SignatureNEQ(*i.SignatureNEQ))
	}
	if len(i.SignatureIn) > 0 {
		predicates = append(predicates, oauthaccesstoken.SignatureIn(i.SignatureIn...))
	}
	if len(i.SignatureNotIn) > 0 {
		predicates = append(predicates, oauthaccesstoken.SignatureNotIn(i.SignatureNotIn...))
	}
	if i.SignatureGT != nil {
		predicates = append(predicates, oauthaccesstoken.SignatureGT(*i.SignatureGT))
	}
	if i.SignatureGTE != nil {
		predicates = append(predicates, oauthaccesstoken.SignatureGTE(*i.SignatureGTE))
	}
	if i.SignatureLT != nil {
		predicates = append(predicates, oauthaccesstoken.SignatureLT(*i.SignatureLT))
	}
	if i.SignatureLTE != nil {
		predicates = append(predicates, oauthaccesstoken.SignatureLTE(*i.SignatureLTE))
	}
	if i.SignatureContains != nil {
		predicates = append(predicates, oauthaccesstoken.SignatureContains(*i.SignatureContains))
	}
	if i.SignatureHasPrefix != nil {
		predicates = append(predicates, oauthaccesstoken.SignatureHasPrefix(*i.SignatureHasPrefix))
	}
	if i.SignatureHasSuffix != nil {
		predicates = append(predicates, oauthaccesstoken.SignatureHasSuffix(*i.SignatureHasSuffix))
	}
	if i.SignatureEqualFold != nil {
		predicates = append(predicates, oauthaccesstoken.SignatureEqualFold(*i.SignatureEqualFold))
	}
	if i.SignatureContainsFold != nil {
		predicates = append(predicates, oauthaccesstoken.SignatureContainsFold(*i.SignatureContainsFold))
	}

	if i.HasSession != nil {
		p := oauthaccesstoken.HasSession()
		if !*i.HasSession {
			p = oauthaccesstoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSessionWith) > 0 {
		with := make([]predicate.OAuthSession, 0, len(i.HasSessionWith))
		for _, w := range i.HasSessionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSessionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, oauthaccesstoken.HasSessionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOAuthAccessTokenWhereInput
	case 1:
		return predicates[0], nil
	default:
		return oauthaccesstoken.And(predicates...), nil
	}
}

// OAuthClientWhereInput represents a where input for filtering OAuthClient queries.
type OAuthClientWhereInput struct {
	Predicates []predicate.OAuthClient  `json:"-"`
	Not        *OAuthClientWhereInput   `json:"not,omitempty"`
	Or         []*OAuthClientWhereInput `json:"or,omitempty"`
	And        []*OAuthClientWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "client_id" field predicates.
	ClientID             *string  `json:"clientID,omitempty"`
	ClientIDNEQ          *string  `json:"clientIDNEQ,omitempty"`
	ClientIDIn           []string `json:"clientIDIn,omitempty"`
	ClientIDNotIn        []string `json:"clientIDNotIn,omitempty"`
	ClientIDGT           *string  `json:"clientIDGT,omitempty"`
	ClientIDGTE          *string  `json:"clientIDGTE,omitempty"`
	ClientIDLT           *string  `json:"clientIDLT,omitempty"`
	ClientIDLTE          *string  `json:"clientIDLTE,omitempty"`
	ClientIDContains     *string  `json:"clientIDContains,omitempty"`
	ClientIDHasPrefix    *string  `json:"clientIDHasPrefix,omitempty"`
	ClientIDHasSuffix    *string  `json:"clientIDHasSuffix,omitempty"`
	ClientIDEqualFold    *string  `json:"clientIDEqualFold,omitempty"`
	ClientIDContainsFold *string  `json:"clientIDContainsFold,omitempty"`

	// "secret" field predicates.
	Secret             *string  `json:"secret,omitempty"`
	SecretNEQ          *string  `json:"secretNEQ,omitempty"`
	SecretIn           []string `json:"secretIn,omitempty"`
	SecretNotIn        []string `json:"secretNotIn,omitempty"`
	SecretGT           *string  `json:"secretGT,omitempty"`
	SecretGTE          *string  `json:"secretGTE,omitempty"`
	SecretLT           *string  `json:"secretLT,omitempty"`
	SecretLTE          *string  `json:"secretLTE,omitempty"`
	SecretContains     *string  `json:"secretContains,omitempty"`
	SecretHasPrefix    *string  `json:"secretHasPrefix,omitempty"`
	SecretHasSuffix    *string  `json:"secretHasSuffix,omitempty"`
	SecretEqualFold    *string  `json:"secretEqualFold,omitempty"`
	SecretContainsFold *string  `json:"secretContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OAuthClientWhereInput) AddPredicates(predicates ...predicate.OAuthClient) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OAuthClientWhereInput filter on the OAuthClientQuery builder.
func (i *OAuthClientWhereInput) Filter(q *OAuthClientQuery) (*OAuthClientQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOAuthClientWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOAuthClientWhereInput is returned in case the OAuthClientWhereInput is empty.
var ErrEmptyOAuthClientWhereInput = errors.New("ent: empty predicate OAuthClientWhereInput")

// P returns a predicate for filtering oauthclients.
// An error is returned if the input is empty or invalid.
func (i *OAuthClientWhereInput) P() (predicate.OAuthClient, error) {
	var predicates []predicate.OAuthClient
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, oauthclient.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OAuthClient, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, oauthclient.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OAuthClient, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, oauthclient.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, oauthclient.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, oauthclient.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, oauthclient.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, oauthclient.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, oauthclient.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, oauthclient.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, oauthclient.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, oauthclient.IDLTE(*i.IDLTE))
	}
	if i.ClientID != nil {
		predicates = append(predicates, oauthclient.ClientIDEQ(*i.ClientID))
	}
	if i.ClientIDNEQ != nil {
		predicates = append(predicates, oauthclient.ClientIDNEQ(*i.ClientIDNEQ))
	}
	if len(i.ClientIDIn) > 0 {
		predicates = append(predicates, oauthclient.ClientIDIn(i.ClientIDIn...))
	}
	if len(i.ClientIDNotIn) > 0 {
		predicates = append(predicates, oauthclient.ClientIDNotIn(i.ClientIDNotIn...))
	}
	if i.ClientIDGT != nil {
		predicates = append(predicates, oauthclient.ClientIDGT(*i.ClientIDGT))
	}
	if i.ClientIDGTE != nil {
		predicates = append(predicates, oauthclient.ClientIDGTE(*i.ClientIDGTE))
	}
	if i.ClientIDLT != nil {
		predicates = append(predicates, oauthclient.ClientIDLT(*i.ClientIDLT))
	}
	if i.ClientIDLTE != nil {
		predicates = append(predicates, oauthclient.ClientIDLTE(*i.ClientIDLTE))
	}
	if i.ClientIDContains != nil {
		predicates = append(predicates, oauthclient.ClientIDContains(*i.ClientIDContains))
	}
	if i.ClientIDHasPrefix != nil {
		predicates = append(predicates, oauthclient.ClientIDHasPrefix(*i.ClientIDHasPrefix))
	}
	if i.ClientIDHasSuffix != nil {
		predicates = append(predicates, oauthclient.ClientIDHasSuffix(*i.ClientIDHasSuffix))
	}
	if i.ClientIDEqualFold != nil {
		predicates = append(predicates, oauthclient.ClientIDEqualFold(*i.ClientIDEqualFold))
	}
	if i.ClientIDContainsFold != nil {
		predicates = append(predicates, oauthclient.ClientIDContainsFold(*i.ClientIDContainsFold))
	}
	if i.Secret != nil {
		predicates = append(predicates, oauthclient.SecretEQ(*i.Secret))
	}
	if i.SecretNEQ != nil {
		predicates = append(predicates, oauthclient.SecretNEQ(*i.SecretNEQ))
	}
	if len(i.SecretIn) > 0 {
		predicates = append(predicates, oauthclient.SecretIn(i.SecretIn...))
	}
	if len(i.SecretNotIn) > 0 {
		predicates = append(predicates, oauthclient.SecretNotIn(i.SecretNotIn...))
	}
	if i.SecretGT != nil {
		predicates = append(predicates, oauthclient.SecretGT(*i.SecretGT))
	}
	if i.SecretGTE != nil {
		predicates = append(predicates, oauthclient.SecretGTE(*i.SecretGTE))
	}
	if i.SecretLT != nil {
		predicates = append(predicates, oauthclient.SecretLT(*i.SecretLT))
	}
	if i.SecretLTE != nil {
		predicates = append(predicates, oauthclient.SecretLTE(*i.SecretLTE))
	}
	if i.SecretContains != nil {
		predicates = append(predicates, oauthclient.SecretContains(*i.SecretContains))
	}
	if i.SecretHasPrefix != nil {
		predicates = append(predicates, oauthclient.SecretHasPrefix(*i.SecretHasPrefix))
	}
	if i.SecretHasSuffix != nil {
		predicates = append(predicates, oauthclient.SecretHasSuffix(*i.SecretHasSuffix))
	}
	if i.SecretEqualFold != nil {
		predicates = append(predicates, oauthclient.SecretEqualFold(*i.SecretEqualFold))
	}
	if i.SecretContainsFold != nil {
		predicates = append(predicates, oauthclient.SecretContainsFold(*i.SecretContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOAuthClientWhereInput
	case 1:
		return predicates[0], nil
	default:
		return oauthclient.And(predicates...), nil
	}
}

// OAuthPARRequestWhereInput represents a where input for filtering OAuthPARRequest queries.
type OAuthPARRequestWhereInput struct {
	Predicates []predicate.OAuthPARRequest  `json:"-"`
	Not        *OAuthPARRequestWhereInput   `json:"not,omitempty"`
	Or         []*OAuthPARRequestWhereInput `json:"or,omitempty"`
	And        []*OAuthPARRequestWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "request" field predicates.
	Request             *string  `json:"request,omitempty"`
	RequestNEQ          *string  `json:"requestNEQ,omitempty"`
	RequestIn           []string `json:"requestIn,omitempty"`
	RequestNotIn        []string `json:"requestNotIn,omitempty"`
	RequestGT           *string  `json:"requestGT,omitempty"`
	RequestGTE          *string  `json:"requestGTE,omitempty"`
	RequestLT           *string  `json:"requestLT,omitempty"`
	RequestLTE          *string  `json:"requestLTE,omitempty"`
	RequestContains     *string  `json:"requestContains,omitempty"`
	RequestHasPrefix    *string  `json:"requestHasPrefix,omitempty"`
	RequestHasSuffix    *string  `json:"requestHasSuffix,omitempty"`
	RequestEqualFold    *string  `json:"requestEqualFold,omitempty"`
	RequestContainsFold *string  `json:"requestContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OAuthPARRequestWhereInput) AddPredicates(predicates ...predicate.OAuthPARRequest) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OAuthPARRequestWhereInput filter on the OAuthPARRequestQuery builder.
func (i *OAuthPARRequestWhereInput) Filter(q *OAuthPARRequestQuery) (*OAuthPARRequestQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOAuthPARRequestWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOAuthPARRequestWhereInput is returned in case the OAuthPARRequestWhereInput is empty.
var ErrEmptyOAuthPARRequestWhereInput = errors.New("ent: empty predicate OAuthPARRequestWhereInput")

// P returns a predicate for filtering oauthparrequests.
// An error is returned if the input is empty or invalid.
func (i *OAuthPARRequestWhereInput) P() (predicate.OAuthPARRequest, error) {
	var predicates []predicate.OAuthPARRequest
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, oauthparrequest.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OAuthPARRequest, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, oauthparrequest.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OAuthPARRequest, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, oauthparrequest.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, oauthparrequest.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, oauthparrequest.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, oauthparrequest.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, oauthparrequest.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, oauthparrequest.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, oauthparrequest.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, oauthparrequest.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, oauthparrequest.IDLTE(*i.IDLTE))
	}
	if i.Request != nil {
		predicates = append(predicates, oauthparrequest.RequestEQ(*i.Request))
	}
	if i.RequestNEQ != nil {
		predicates = append(predicates, oauthparrequest.RequestNEQ(*i.RequestNEQ))
	}
	if len(i.RequestIn) > 0 {
		predicates = append(predicates, oauthparrequest.RequestIn(i.RequestIn...))
	}
	if len(i.RequestNotIn) > 0 {
		predicates = append(predicates, oauthparrequest.RequestNotIn(i.RequestNotIn...))
	}
	if i.RequestGT != nil {
		predicates = append(predicates, oauthparrequest.RequestGT(*i.RequestGT))
	}
	if i.RequestGTE != nil {
		predicates = append(predicates, oauthparrequest.RequestGTE(*i.RequestGTE))
	}
	if i.RequestLT != nil {
		predicates = append(predicates, oauthparrequest.RequestLT(*i.RequestLT))
	}
	if i.RequestLTE != nil {
		predicates = append(predicates, oauthparrequest.RequestLTE(*i.RequestLTE))
	}
	if i.RequestContains != nil {
		predicates = append(predicates, oauthparrequest.RequestContains(*i.RequestContains))
	}
	if i.RequestHasPrefix != nil {
		predicates = append(predicates, oauthparrequest.RequestHasPrefix(*i.RequestHasPrefix))
	}
	if i.RequestHasSuffix != nil {
		predicates = append(predicates, oauthparrequest.RequestHasSuffix(*i.RequestHasSuffix))
	}
	if i.RequestEqualFold != nil {
		predicates = append(predicates, oauthparrequest.RequestEqualFold(*i.RequestEqualFold))
	}
	if i.RequestContainsFold != nil {
		predicates = append(predicates, oauthparrequest.RequestContainsFold(*i.RequestContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOAuthPARRequestWhereInput
	case 1:
		return predicates[0], nil
	default:
		return oauthparrequest.And(predicates...), nil
	}
}

// OAuthRefreshTokenWhereInput represents a where input for filtering OAuthRefreshToken queries.
type OAuthRefreshTokenWhereInput struct {
	Predicates []predicate.OAuthRefreshToken  `json:"-"`
	Not        *OAuthRefreshTokenWhereInput   `json:"not,omitempty"`
	Or         []*OAuthRefreshTokenWhereInput `json:"or,omitempty"`
	And        []*OAuthRefreshTokenWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "signature" field predicates.
	Signature             *string  `json:"signature,omitempty"`
	SignatureNEQ          *string  `json:"signatureNEQ,omitempty"`
	SignatureIn           []string `json:"signatureIn,omitempty"`
	SignatureNotIn        []string `json:"signatureNotIn,omitempty"`
	SignatureGT           *string  `json:"signatureGT,omitempty"`
	SignatureGTE          *string  `json:"signatureGTE,omitempty"`
	SignatureLT           *string  `json:"signatureLT,omitempty"`
	SignatureLTE          *string  `json:"signatureLTE,omitempty"`
	SignatureContains     *string  `json:"signatureContains,omitempty"`
	SignatureHasPrefix    *string  `json:"signatureHasPrefix,omitempty"`
	SignatureHasSuffix    *string  `json:"signatureHasSuffix,omitempty"`
	SignatureEqualFold    *string  `json:"signatureEqualFold,omitempty"`
	SignatureContainsFold *string  `json:"signatureContainsFold,omitempty"`

	// "session" edge predicates.
	HasSession     *bool                     `json:"hasSession,omitempty"`
	HasSessionWith []*OAuthSessionWhereInput `json:"hasSessionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OAuthRefreshTokenWhereInput) AddPredicates(predicates ...predicate.OAuthRefreshToken) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OAuthRefreshTokenWhereInput filter on the OAuthRefreshTokenQuery builder.
func (i *OAuthRefreshTokenWhereInput) Filter(q *OAuthRefreshTokenQuery) (*OAuthRefreshTokenQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOAuthRefreshTokenWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOAuthRefreshTokenWhereInput is returned in case the OAuthRefreshTokenWhereInput is empty.
var ErrEmptyOAuthRefreshTokenWhereInput = errors.New("ent: empty predicate OAuthRefreshTokenWhereInput")

// P returns a predicate for filtering oauthrefreshtokens.
// An error is returned if the input is empty or invalid.
func (i *OAuthRefreshTokenWhereInput) P() (predicate.OAuthRefreshToken, error) {
	var predicates []predicate.OAuthRefreshToken
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, oauthrefreshtoken.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OAuthRefreshToken, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, oauthrefreshtoken.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OAuthRefreshToken, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, oauthrefreshtoken.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, oauthrefreshtoken.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, oauthrefreshtoken.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, oauthrefreshtoken.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, oauthrefreshtoken.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, oauthrefreshtoken.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, oauthrefreshtoken.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, oauthrefreshtoken.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, oauthrefreshtoken.IDLTE(*i.IDLTE))
	}
	if i.Signature != nil {
		predicates = append(predicates, oauthrefreshtoken.SignatureEQ(*i.Signature))
	}
	if i.SignatureNEQ != nil {
		predicates = append(predicates, oauthrefreshtoken.SignatureNEQ(*i.SignatureNEQ))
	}
	if len(i.SignatureIn) > 0 {
		predicates = append(predicates, oauthrefreshtoken.SignatureIn(i.SignatureIn...))
	}
	if len(i.SignatureNotIn) > 0 {
		predicates = append(predicates, oauthrefreshtoken.SignatureNotIn(i.SignatureNotIn...))
	}
	if i.SignatureGT != nil {
		predicates = append(predicates, oauthrefreshtoken.SignatureGT(*i.SignatureGT))
	}
	if i.SignatureGTE != nil {
		predicates = append(predicates, oauthrefreshtoken.SignatureGTE(*i.SignatureGTE))
	}
	if i.SignatureLT != nil {
		predicates = append(predicates, oauthrefreshtoken.SignatureLT(*i.SignatureLT))
	}
	if i.SignatureLTE != nil {
		predicates = append(predicates, oauthrefreshtoken.SignatureLTE(*i.SignatureLTE))
	}
	if i.SignatureContains != nil {
		predicates = append(predicates, oauthrefreshtoken.SignatureContains(*i.SignatureContains))
	}
	if i.SignatureHasPrefix != nil {
		predicates = append(predicates, oauthrefreshtoken.SignatureHasPrefix(*i.SignatureHasPrefix))
	}
	if i.SignatureHasSuffix != nil {
		predicates = append(predicates, oauthrefreshtoken.SignatureHasSuffix(*i.SignatureHasSuffix))
	}
	if i.SignatureEqualFold != nil {
		predicates = append(predicates, oauthrefreshtoken.SignatureEqualFold(*i.SignatureEqualFold))
	}
	if i.SignatureContainsFold != nil {
		predicates = append(predicates, oauthrefreshtoken.SignatureContainsFold(*i.SignatureContainsFold))
	}

	if i.HasSession != nil {
		p := oauthrefreshtoken.HasSession()
		if !*i.HasSession {
			p = oauthrefreshtoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSessionWith) > 0 {
		with := make([]predicate.OAuthSession, 0, len(i.HasSessionWith))
		for _, w := range i.HasSessionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSessionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, oauthrefreshtoken.HasSessionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOAuthRefreshTokenWhereInput
	case 1:
		return predicates[0], nil
	default:
		return oauthrefreshtoken.And(predicates...), nil
	}
}

// OAuthSessionWhereInput represents a where input for filtering OAuthSession queries.
type OAuthSessionWhereInput struct {
	Predicates []predicate.OAuthSession  `json:"-"`
	Not        *OAuthSessionWhereInput   `json:"not,omitempty"`
	Or         []*OAuthSessionWhereInput `json:"or,omitempty"`
	And        []*OAuthSessionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "issuer" field predicates.
	Issuer             *string  `json:"issuer,omitempty"`
	IssuerNEQ          *string  `json:"issuerNEQ,omitempty"`
	IssuerIn           []string `json:"issuerIn,omitempty"`
	IssuerNotIn        []string `json:"issuerNotIn,omitempty"`
	IssuerGT           *string  `json:"issuerGT,omitempty"`
	IssuerGTE          *string  `json:"issuerGTE,omitempty"`
	IssuerLT           *string  `json:"issuerLT,omitempty"`
	IssuerLTE          *string  `json:"issuerLTE,omitempty"`
	IssuerContains     *string  `json:"issuerContains,omitempty"`
	IssuerHasPrefix    *string  `json:"issuerHasPrefix,omitempty"`
	IssuerHasSuffix    *string  `json:"issuerHasSuffix,omitempty"`
	IssuerEqualFold    *string  `json:"issuerEqualFold,omitempty"`
	IssuerContainsFold *string  `json:"issuerContainsFold,omitempty"`

	// "subject" field predicates.
	Subject             *string  `json:"subject,omitempty"`
	SubjectNEQ          *string  `json:"subjectNEQ,omitempty"`
	SubjectIn           []string `json:"subjectIn,omitempty"`
	SubjectNotIn        []string `json:"subjectNotIn,omitempty"`
	SubjectGT           *string  `json:"subjectGT,omitempty"`
	SubjectGTE          *string  `json:"subjectGTE,omitempty"`
	SubjectLT           *string  `json:"subjectLT,omitempty"`
	SubjectLTE          *string  `json:"subjectLTE,omitempty"`
	SubjectContains     *string  `json:"subjectContains,omitempty"`
	SubjectHasPrefix    *string  `json:"subjectHasPrefix,omitempty"`
	SubjectHasSuffix    *string  `json:"subjectHasSuffix,omitempty"`
	SubjectEqualFold    *string  `json:"subjectEqualFold,omitempty"`
	SubjectContainsFold *string  `json:"subjectContainsFold,omitempty"`

	// "expires_at" field predicates.
	ExpiresAt      *time.Time  `json:"expiresAt,omitempty"`
	ExpiresAtNEQ   *time.Time  `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn    []time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn []time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGT    *time.Time  `json:"expiresAtGT,omitempty"`
	ExpiresAtGTE   *time.Time  `json:"expiresAtGTE,omitempty"`
	ExpiresAtLT    *time.Time  `json:"expiresAtLT,omitempty"`
	ExpiresAtLTE   *time.Time  `json:"expiresAtLTE,omitempty"`

	// "issued_at" field predicates.
	IssuedAt      *time.Time  `json:"issuedAt,omitempty"`
	IssuedAtNEQ   *time.Time  `json:"issuedAtNEQ,omitempty"`
	IssuedAtIn    []time.Time `json:"issuedAtIn,omitempty"`
	IssuedAtNotIn []time.Time `json:"issuedAtNotIn,omitempty"`
	IssuedAtGT    *time.Time  `json:"issuedAtGT,omitempty"`
	IssuedAtGTE   *time.Time  `json:"issuedAtGTE,omitempty"`
	IssuedAtLT    *time.Time  `json:"issuedAtLT,omitempty"`
	IssuedAtLTE   *time.Time  `json:"issuedAtLTE,omitempty"`

	// "requested_at" field predicates.
	RequestedAt      *time.Time  `json:"requestedAt,omitempty"`
	RequestedAtNEQ   *time.Time  `json:"requestedAtNEQ,omitempty"`
	RequestedAtIn    []time.Time `json:"requestedAtIn,omitempty"`
	RequestedAtNotIn []time.Time `json:"requestedAtNotIn,omitempty"`
	RequestedAtGT    *time.Time  `json:"requestedAtGT,omitempty"`
	RequestedAtGTE   *time.Time  `json:"requestedAtGTE,omitempty"`
	RequestedAtLT    *time.Time  `json:"requestedAtLT,omitempty"`
	RequestedAtLTE   *time.Time  `json:"requestedAtLTE,omitempty"`

	// "auth_time" field predicates.
	AuthTime      *time.Time  `json:"authTime,omitempty"`
	AuthTimeNEQ   *time.Time  `json:"authTimeNEQ,omitempty"`
	AuthTimeIn    []time.Time `json:"authTimeIn,omitempty"`
	AuthTimeNotIn []time.Time `json:"authTimeNotIn,omitempty"`
	AuthTimeGT    *time.Time  `json:"authTimeGT,omitempty"`
	AuthTimeGTE   *time.Time  `json:"authTimeGTE,omitempty"`
	AuthTimeLT    *time.Time  `json:"authTimeLT,omitempty"`
	AuthTimeLTE   *time.Time  `json:"authTimeLTE,omitempty"`

	// "request" field predicates.
	Request             *string  `json:"request,omitempty"`
	RequestNEQ          *string  `json:"requestNEQ,omitempty"`
	RequestIn           []string `json:"requestIn,omitempty"`
	RequestNotIn        []string `json:"requestNotIn,omitempty"`
	RequestGT           *string  `json:"requestGT,omitempty"`
	RequestGTE          *string  `json:"requestGTE,omitempty"`
	RequestLT           *string  `json:"requestLT,omitempty"`
	RequestLTE          *string  `json:"requestLTE,omitempty"`
	RequestContains     *string  `json:"requestContains,omitempty"`
	RequestHasPrefix    *string  `json:"requestHasPrefix,omitempty"`
	RequestHasSuffix    *string  `json:"requestHasSuffix,omitempty"`
	RequestEqualFold    *string  `json:"requestEqualFold,omitempty"`
	RequestContainsFold *string  `json:"requestContainsFold,omitempty"`

	// "form" field predicates.
	Form             *string  `json:"form,omitempty"`
	FormNEQ          *string  `json:"formNEQ,omitempty"`
	FormIn           []string `json:"formIn,omitempty"`
	FormNotIn        []string `json:"formNotIn,omitempty"`
	FormGT           *string  `json:"formGT,omitempty"`
	FormGTE          *string  `json:"formGTE,omitempty"`
	FormLT           *string  `json:"formLT,omitempty"`
	FormLTE          *string  `json:"formLTE,omitempty"`
	FormContains     *string  `json:"formContains,omitempty"`
	FormHasPrefix    *string  `json:"formHasPrefix,omitempty"`
	FormHasSuffix    *string  `json:"formHasSuffix,omitempty"`
	FormEqualFold    *string  `json:"formEqualFold,omitempty"`
	FormContainsFold *string  `json:"formContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OAuthSessionWhereInput) AddPredicates(predicates ...predicate.OAuthSession) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OAuthSessionWhereInput filter on the OAuthSessionQuery builder.
func (i *OAuthSessionWhereInput) Filter(q *OAuthSessionQuery) (*OAuthSessionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOAuthSessionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOAuthSessionWhereInput is returned in case the OAuthSessionWhereInput is empty.
var ErrEmptyOAuthSessionWhereInput = errors.New("ent: empty predicate OAuthSessionWhereInput")

// P returns a predicate for filtering oauthsessions.
// An error is returned if the input is empty or invalid.
func (i *OAuthSessionWhereInput) P() (predicate.OAuthSession, error) {
	var predicates []predicate.OAuthSession
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, oauthsession.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OAuthSession, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, oauthsession.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OAuthSession, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, oauthsession.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, oauthsession.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, oauthsession.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, oauthsession.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, oauthsession.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, oauthsession.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, oauthsession.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, oauthsession.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, oauthsession.IDLTE(*i.IDLTE))
	}
	if i.Issuer != nil {
		predicates = append(predicates, oauthsession.IssuerEQ(*i.Issuer))
	}
	if i.IssuerNEQ != nil {
		predicates = append(predicates, oauthsession.IssuerNEQ(*i.IssuerNEQ))
	}
	if len(i.IssuerIn) > 0 {
		predicates = append(predicates, oauthsession.IssuerIn(i.IssuerIn...))
	}
	if len(i.IssuerNotIn) > 0 {
		predicates = append(predicates, oauthsession.IssuerNotIn(i.IssuerNotIn...))
	}
	if i.IssuerGT != nil {
		predicates = append(predicates, oauthsession.IssuerGT(*i.IssuerGT))
	}
	if i.IssuerGTE != nil {
		predicates = append(predicates, oauthsession.IssuerGTE(*i.IssuerGTE))
	}
	if i.IssuerLT != nil {
		predicates = append(predicates, oauthsession.IssuerLT(*i.IssuerLT))
	}
	if i.IssuerLTE != nil {
		predicates = append(predicates, oauthsession.IssuerLTE(*i.IssuerLTE))
	}
	if i.IssuerContains != nil {
		predicates = append(predicates, oauthsession.IssuerContains(*i.IssuerContains))
	}
	if i.IssuerHasPrefix != nil {
		predicates = append(predicates, oauthsession.IssuerHasPrefix(*i.IssuerHasPrefix))
	}
	if i.IssuerHasSuffix != nil {
		predicates = append(predicates, oauthsession.IssuerHasSuffix(*i.IssuerHasSuffix))
	}
	if i.IssuerEqualFold != nil {
		predicates = append(predicates, oauthsession.IssuerEqualFold(*i.IssuerEqualFold))
	}
	if i.IssuerContainsFold != nil {
		predicates = append(predicates, oauthsession.IssuerContainsFold(*i.IssuerContainsFold))
	}
	if i.Subject != nil {
		predicates = append(predicates, oauthsession.SubjectEQ(*i.Subject))
	}
	if i.SubjectNEQ != nil {
		predicates = append(predicates, oauthsession.SubjectNEQ(*i.SubjectNEQ))
	}
	if len(i.SubjectIn) > 0 {
		predicates = append(predicates, oauthsession.SubjectIn(i.SubjectIn...))
	}
	if len(i.SubjectNotIn) > 0 {
		predicates = append(predicates, oauthsession.SubjectNotIn(i.SubjectNotIn...))
	}
	if i.SubjectGT != nil {
		predicates = append(predicates, oauthsession.SubjectGT(*i.SubjectGT))
	}
	if i.SubjectGTE != nil {
		predicates = append(predicates, oauthsession.SubjectGTE(*i.SubjectGTE))
	}
	if i.SubjectLT != nil {
		predicates = append(predicates, oauthsession.SubjectLT(*i.SubjectLT))
	}
	if i.SubjectLTE != nil {
		predicates = append(predicates, oauthsession.SubjectLTE(*i.SubjectLTE))
	}
	if i.SubjectContains != nil {
		predicates = append(predicates, oauthsession.SubjectContains(*i.SubjectContains))
	}
	if i.SubjectHasPrefix != nil {
		predicates = append(predicates, oauthsession.SubjectHasPrefix(*i.SubjectHasPrefix))
	}
	if i.SubjectHasSuffix != nil {
		predicates = append(predicates, oauthsession.SubjectHasSuffix(*i.SubjectHasSuffix))
	}
	if i.SubjectEqualFold != nil {
		predicates = append(predicates, oauthsession.SubjectEqualFold(*i.SubjectEqualFold))
	}
	if i.SubjectContainsFold != nil {
		predicates = append(predicates, oauthsession.SubjectContainsFold(*i.SubjectContainsFold))
	}
	if i.ExpiresAt != nil {
		predicates = append(predicates, oauthsession.ExpiresAtEQ(*i.ExpiresAt))
	}
	if i.ExpiresAtNEQ != nil {
		predicates = append(predicates, oauthsession.ExpiresAtNEQ(*i.ExpiresAtNEQ))
	}
	if len(i.ExpiresAtIn) > 0 {
		predicates = append(predicates, oauthsession.ExpiresAtIn(i.ExpiresAtIn...))
	}
	if len(i.ExpiresAtNotIn) > 0 {
		predicates = append(predicates, oauthsession.ExpiresAtNotIn(i.ExpiresAtNotIn...))
	}
	if i.ExpiresAtGT != nil {
		predicates = append(predicates, oauthsession.ExpiresAtGT(*i.ExpiresAtGT))
	}
	if i.ExpiresAtGTE != nil {
		predicates = append(predicates, oauthsession.ExpiresAtGTE(*i.ExpiresAtGTE))
	}
	if i.ExpiresAtLT != nil {
		predicates = append(predicates, oauthsession.ExpiresAtLT(*i.ExpiresAtLT))
	}
	if i.ExpiresAtLTE != nil {
		predicates = append(predicates, oauthsession.ExpiresAtLTE(*i.ExpiresAtLTE))
	}
	if i.IssuedAt != nil {
		predicates = append(predicates, oauthsession.IssuedAtEQ(*i.IssuedAt))
	}
	if i.IssuedAtNEQ != nil {
		predicates = append(predicates, oauthsession.IssuedAtNEQ(*i.IssuedAtNEQ))
	}
	if len(i.IssuedAtIn) > 0 {
		predicates = append(predicates, oauthsession.IssuedAtIn(i.IssuedAtIn...))
	}
	if len(i.IssuedAtNotIn) > 0 {
		predicates = append(predicates, oauthsession.IssuedAtNotIn(i.IssuedAtNotIn...))
	}
	if i.IssuedAtGT != nil {
		predicates = append(predicates, oauthsession.IssuedAtGT(*i.IssuedAtGT))
	}
	if i.IssuedAtGTE != nil {
		predicates = append(predicates, oauthsession.IssuedAtGTE(*i.IssuedAtGTE))
	}
	if i.IssuedAtLT != nil {
		predicates = append(predicates, oauthsession.IssuedAtLT(*i.IssuedAtLT))
	}
	if i.IssuedAtLTE != nil {
		predicates = append(predicates, oauthsession.IssuedAtLTE(*i.IssuedAtLTE))
	}
	if i.RequestedAt != nil {
		predicates = append(predicates, oauthsession.RequestedAtEQ(*i.RequestedAt))
	}
	if i.RequestedAtNEQ != nil {
		predicates = append(predicates, oauthsession.RequestedAtNEQ(*i.RequestedAtNEQ))
	}
	if len(i.RequestedAtIn) > 0 {
		predicates = append(predicates, oauthsession.RequestedAtIn(i.RequestedAtIn...))
	}
	if len(i.RequestedAtNotIn) > 0 {
		predicates = append(predicates, oauthsession.RequestedAtNotIn(i.RequestedAtNotIn...))
	}
	if i.RequestedAtGT != nil {
		predicates = append(predicates, oauthsession.RequestedAtGT(*i.RequestedAtGT))
	}
	if i.RequestedAtGTE != nil {
		predicates = append(predicates, oauthsession.RequestedAtGTE(*i.RequestedAtGTE))
	}
	if i.RequestedAtLT != nil {
		predicates = append(predicates, oauthsession.RequestedAtLT(*i.RequestedAtLT))
	}
	if i.RequestedAtLTE != nil {
		predicates = append(predicates, oauthsession.RequestedAtLTE(*i.RequestedAtLTE))
	}
	if i.AuthTime != nil {
		predicates = append(predicates, oauthsession.AuthTimeEQ(*i.AuthTime))
	}
	if i.AuthTimeNEQ != nil {
		predicates = append(predicates, oauthsession.AuthTimeNEQ(*i.AuthTimeNEQ))
	}
	if len(i.AuthTimeIn) > 0 {
		predicates = append(predicates, oauthsession.AuthTimeIn(i.AuthTimeIn...))
	}
	if len(i.AuthTimeNotIn) > 0 {
		predicates = append(predicates, oauthsession.AuthTimeNotIn(i.AuthTimeNotIn...))
	}
	if i.AuthTimeGT != nil {
		predicates = append(predicates, oauthsession.AuthTimeGT(*i.AuthTimeGT))
	}
	if i.AuthTimeGTE != nil {
		predicates = append(predicates, oauthsession.AuthTimeGTE(*i.AuthTimeGTE))
	}
	if i.AuthTimeLT != nil {
		predicates = append(predicates, oauthsession.AuthTimeLT(*i.AuthTimeLT))
	}
	if i.AuthTimeLTE != nil {
		predicates = append(predicates, oauthsession.AuthTimeLTE(*i.AuthTimeLTE))
	}
	if i.Request != nil {
		predicates = append(predicates, oauthsession.RequestEQ(*i.Request))
	}
	if i.RequestNEQ != nil {
		predicates = append(predicates, oauthsession.RequestNEQ(*i.RequestNEQ))
	}
	if len(i.RequestIn) > 0 {
		predicates = append(predicates, oauthsession.RequestIn(i.RequestIn...))
	}
	if len(i.RequestNotIn) > 0 {
		predicates = append(predicates, oauthsession.RequestNotIn(i.RequestNotIn...))
	}
	if i.RequestGT != nil {
		predicates = append(predicates, oauthsession.RequestGT(*i.RequestGT))
	}
	if i.RequestGTE != nil {
		predicates = append(predicates, oauthsession.RequestGTE(*i.RequestGTE))
	}
	if i.RequestLT != nil {
		predicates = append(predicates, oauthsession.RequestLT(*i.RequestLT))
	}
	if i.RequestLTE != nil {
		predicates = append(predicates, oauthsession.RequestLTE(*i.RequestLTE))
	}
	if i.RequestContains != nil {
		predicates = append(predicates, oauthsession.RequestContains(*i.RequestContains))
	}
	if i.RequestHasPrefix != nil {
		predicates = append(predicates, oauthsession.RequestHasPrefix(*i.RequestHasPrefix))
	}
	if i.RequestHasSuffix != nil {
		predicates = append(predicates, oauthsession.RequestHasSuffix(*i.RequestHasSuffix))
	}
	if i.RequestEqualFold != nil {
		predicates = append(predicates, oauthsession.RequestEqualFold(*i.RequestEqualFold))
	}
	if i.RequestContainsFold != nil {
		predicates = append(predicates, oauthsession.RequestContainsFold(*i.RequestContainsFold))
	}
	if i.Form != nil {
		predicates = append(predicates, oauthsession.FormEQ(*i.Form))
	}
	if i.FormNEQ != nil {
		predicates = append(predicates, oauthsession.FormNEQ(*i.FormNEQ))
	}
	if len(i.FormIn) > 0 {
		predicates = append(predicates, oauthsession.FormIn(i.FormIn...))
	}
	if len(i.FormNotIn) > 0 {
		predicates = append(predicates, oauthsession.FormNotIn(i.FormNotIn...))
	}
	if i.FormGT != nil {
		predicates = append(predicates, oauthsession.FormGT(*i.FormGT))
	}
	if i.FormGTE != nil {
		predicates = append(predicates, oauthsession.FormGTE(*i.FormGTE))
	}
	if i.FormLT != nil {
		predicates = append(predicates, oauthsession.FormLT(*i.FormLT))
	}
	if i.FormLTE != nil {
		predicates = append(predicates, oauthsession.FormLTE(*i.FormLTE))
	}
	if i.FormContains != nil {
		predicates = append(predicates, oauthsession.FormContains(*i.FormContains))
	}
	if i.FormHasPrefix != nil {
		predicates = append(predicates, oauthsession.FormHasPrefix(*i.FormHasPrefix))
	}
	if i.FormHasSuffix != nil {
		predicates = append(predicates, oauthsession.FormHasSuffix(*i.FormHasSuffix))
	}
	if i.FormEqualFold != nil {
		predicates = append(predicates, oauthsession.FormEqualFold(*i.FormEqualFold))
	}
	if i.FormContainsFold != nil {
		predicates = append(predicates, oauthsession.FormContainsFold(*i.FormContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOAuthSessionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return oauthsession.And(predicates...), nil
	}
}

// OIDCAuthCodeWhereInput represents a where input for filtering OIDCAuthCode queries.
type OIDCAuthCodeWhereInput struct {
	Predicates []predicate.OIDCAuthCode  `json:"-"`
	Not        *OIDCAuthCodeWhereInput   `json:"not,omitempty"`
	Or         []*OIDCAuthCodeWhereInput `json:"or,omitempty"`
	And        []*OIDCAuthCodeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "authorization_code" field predicates.
	AuthorizationCode             *string  `json:"authorizationCode,omitempty"`
	AuthorizationCodeNEQ          *string  `json:"authorizationCodeNEQ,omitempty"`
	AuthorizationCodeIn           []string `json:"authorizationCodeIn,omitempty"`
	AuthorizationCodeNotIn        []string `json:"authorizationCodeNotIn,omitempty"`
	AuthorizationCodeGT           *string  `json:"authorizationCodeGT,omitempty"`
	AuthorizationCodeGTE          *string  `json:"authorizationCodeGTE,omitempty"`
	AuthorizationCodeLT           *string  `json:"authorizationCodeLT,omitempty"`
	AuthorizationCodeLTE          *string  `json:"authorizationCodeLTE,omitempty"`
	AuthorizationCodeContains     *string  `json:"authorizationCodeContains,omitempty"`
	AuthorizationCodeHasPrefix    *string  `json:"authorizationCodeHasPrefix,omitempty"`
	AuthorizationCodeHasSuffix    *string  `json:"authorizationCodeHasSuffix,omitempty"`
	AuthorizationCodeEqualFold    *string  `json:"authorizationCodeEqualFold,omitempty"`
	AuthorizationCodeContainsFold *string  `json:"authorizationCodeContainsFold,omitempty"`

	// "session" edge predicates.
	HasSession     *bool                     `json:"hasSession,omitempty"`
	HasSessionWith []*OAuthSessionWhereInput `json:"hasSessionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OIDCAuthCodeWhereInput) AddPredicates(predicates ...predicate.OIDCAuthCode) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OIDCAuthCodeWhereInput filter on the OIDCAuthCodeQuery builder.
func (i *OIDCAuthCodeWhereInput) Filter(q *OIDCAuthCodeQuery) (*OIDCAuthCodeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOIDCAuthCodeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOIDCAuthCodeWhereInput is returned in case the OIDCAuthCodeWhereInput is empty.
var ErrEmptyOIDCAuthCodeWhereInput = errors.New("ent: empty predicate OIDCAuthCodeWhereInput")

// P returns a predicate for filtering oidcauthcodes.
// An error is returned if the input is empty or invalid.
func (i *OIDCAuthCodeWhereInput) P() (predicate.OIDCAuthCode, error) {
	var predicates []predicate.OIDCAuthCode
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, oidcauthcode.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OIDCAuthCode, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, oidcauthcode.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OIDCAuthCode, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, oidcauthcode.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, oidcauthcode.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, oidcauthcode.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, oidcauthcode.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, oidcauthcode.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, oidcauthcode.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, oidcauthcode.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, oidcauthcode.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, oidcauthcode.IDLTE(*i.IDLTE))
	}
	if i.AuthorizationCode != nil {
		predicates = append(predicates, oidcauthcode.AuthorizationCodeEQ(*i.AuthorizationCode))
	}
	if i.AuthorizationCodeNEQ != nil {
		predicates = append(predicates, oidcauthcode.AuthorizationCodeNEQ(*i.AuthorizationCodeNEQ))
	}
	if len(i.AuthorizationCodeIn) > 0 {
		predicates = append(predicates, oidcauthcode.AuthorizationCodeIn(i.AuthorizationCodeIn...))
	}
	if len(i.AuthorizationCodeNotIn) > 0 {
		predicates = append(predicates, oidcauthcode.AuthorizationCodeNotIn(i.AuthorizationCodeNotIn...))
	}
	if i.AuthorizationCodeGT != nil {
		predicates = append(predicates, oidcauthcode.AuthorizationCodeGT(*i.AuthorizationCodeGT))
	}
	if i.AuthorizationCodeGTE != nil {
		predicates = append(predicates, oidcauthcode.AuthorizationCodeGTE(*i.AuthorizationCodeGTE))
	}
	if i.AuthorizationCodeLT != nil {
		predicates = append(predicates, oidcauthcode.AuthorizationCodeLT(*i.AuthorizationCodeLT))
	}
	if i.AuthorizationCodeLTE != nil {
		predicates = append(predicates, oidcauthcode.AuthorizationCodeLTE(*i.AuthorizationCodeLTE))
	}
	if i.AuthorizationCodeContains != nil {
		predicates = append(predicates, oidcauthcode.AuthorizationCodeContains(*i.AuthorizationCodeContains))
	}
	if i.AuthorizationCodeHasPrefix != nil {
		predicates = append(predicates, oidcauthcode.AuthorizationCodeHasPrefix(*i.AuthorizationCodeHasPrefix))
	}
	if i.AuthorizationCodeHasSuffix != nil {
		predicates = append(predicates, oidcauthcode.AuthorizationCodeHasSuffix(*i.AuthorizationCodeHasSuffix))
	}
	if i.AuthorizationCodeEqualFold != nil {
		predicates = append(predicates, oidcauthcode.AuthorizationCodeEqualFold(*i.AuthorizationCodeEqualFold))
	}
	if i.AuthorizationCodeContainsFold != nil {
		predicates = append(predicates, oidcauthcode.AuthorizationCodeContainsFold(*i.AuthorizationCodeContainsFold))
	}

	if i.HasSession != nil {
		p := oidcauthcode.HasSession()
		if !*i.HasSession {
			p = oidcauthcode.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSessionWith) > 0 {
		with := make([]predicate.OAuthSession, 0, len(i.HasSessionWith))
		for _, w := range i.HasSessionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSessionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, oidcauthcode.HasSessionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOIDCAuthCodeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return oidcauthcode.And(predicates...), nil
	}
}

// PKCEWhereInput represents a where input for filtering PKCE queries.
type PKCEWhereInput struct {
	Predicates []predicate.PKCE  `json:"-"`
	Not        *PKCEWhereInput   `json:"not,omitempty"`
	Or         []*PKCEWhereInput `json:"or,omitempty"`
	And        []*PKCEWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "session" edge predicates.
	HasSession     *bool                     `json:"hasSession,omitempty"`
	HasSessionWith []*OAuthSessionWhereInput `json:"hasSessionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PKCEWhereInput) AddPredicates(predicates ...predicate.PKCE) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PKCEWhereInput filter on the PKCEQuery builder.
func (i *PKCEWhereInput) Filter(q *PKCEQuery) (*PKCEQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPKCEWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPKCEWhereInput is returned in case the PKCEWhereInput is empty.
var ErrEmptyPKCEWhereInput = errors.New("ent: empty predicate PKCEWhereInput")

// P returns a predicate for filtering pkces.
// An error is returned if the input is empty or invalid.
func (i *PKCEWhereInput) P() (predicate.PKCE, error) {
	var predicates []predicate.PKCE
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, pkce.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PKCE, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, pkce.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PKCE, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, pkce.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, pkce.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, pkce.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, pkce.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, pkce.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, pkce.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, pkce.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, pkce.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, pkce.IDLTE(*i.IDLTE))
	}
	if i.Code != nil {
		predicates = append(predicates, pkce.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, pkce.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, pkce.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, pkce.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, pkce.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, pkce.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, pkce.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, pkce.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, pkce.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, pkce.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, pkce.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, pkce.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, pkce.CodeContainsFold(*i.CodeContainsFold))
	}

	if i.HasSession != nil {
		p := pkce.HasSession()
		if !*i.HasSession {
			p = pkce.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSessionWith) > 0 {
		with := make([]predicate.OAuthSession, 0, len(i.HasSessionWith))
		for _, w := range i.HasSessionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSessionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, pkce.HasSessionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPKCEWhereInput
	case 1:
		return predicates[0], nil
	default:
		return pkce.And(predicates...), nil
	}
}

// PublicJWKWhereInput represents a where input for filtering PublicJWK queries.
type PublicJWKWhereInput struct {
	Predicates []predicate.PublicJWK  `json:"-"`
	Not        *PublicJWKWhereInput   `json:"not,omitempty"`
	Or         []*PublicJWKWhereInput `json:"or,omitempty"`
	And        []*PublicJWKWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "sid" field predicates.
	Sid             *string  `json:"sid,omitempty"`
	SidNEQ          *string  `json:"sidNEQ,omitempty"`
	SidIn           []string `json:"sidIn,omitempty"`
	SidNotIn        []string `json:"sidNotIn,omitempty"`
	SidGT           *string  `json:"sidGT,omitempty"`
	SidGTE          *string  `json:"sidGTE,omitempty"`
	SidLT           *string  `json:"sidLT,omitempty"`
	SidLTE          *string  `json:"sidLTE,omitempty"`
	SidContains     *string  `json:"sidContains,omitempty"`
	SidHasPrefix    *string  `json:"sidHasPrefix,omitempty"`
	SidHasSuffix    *string  `json:"sidHasSuffix,omitempty"`
	SidEqualFold    *string  `json:"sidEqualFold,omitempty"`
	SidContainsFold *string  `json:"sidContainsFold,omitempty"`

	// "kid" field predicates.
	Kid             *string  `json:"kid,omitempty"`
	KidNEQ          *string  `json:"kidNEQ,omitempty"`
	KidIn           []string `json:"kidIn,omitempty"`
	KidNotIn        []string `json:"kidNotIn,omitempty"`
	KidGT           *string  `json:"kidGT,omitempty"`
	KidGTE          *string  `json:"kidGTE,omitempty"`
	KidLT           *string  `json:"kidLT,omitempty"`
	KidLTE          *string  `json:"kidLTE,omitempty"`
	KidContains     *string  `json:"kidContains,omitempty"`
	KidHasPrefix    *string  `json:"kidHasPrefix,omitempty"`
	KidHasSuffix    *string  `json:"kidHasSuffix,omitempty"`
	KidEqualFold    *string  `json:"kidEqualFold,omitempty"`
	KidContainsFold *string  `json:"kidContainsFold,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "issuer" field predicates.
	Issuer             *string  `json:"issuer,omitempty"`
	IssuerNEQ          *string  `json:"issuerNEQ,omitempty"`
	IssuerIn           []string `json:"issuerIn,omitempty"`
	IssuerNotIn        []string `json:"issuerNotIn,omitempty"`
	IssuerGT           *string  `json:"issuerGT,omitempty"`
	IssuerGTE          *string  `json:"issuerGTE,omitempty"`
	IssuerLT           *string  `json:"issuerLT,omitempty"`
	IssuerLTE          *string  `json:"issuerLTE,omitempty"`
	IssuerContains     *string  `json:"issuerContains,omitempty"`
	IssuerHasPrefix    *string  `json:"issuerHasPrefix,omitempty"`
	IssuerHasSuffix    *string  `json:"issuerHasSuffix,omitempty"`
	IssuerEqualFold    *string  `json:"issuerEqualFold,omitempty"`
	IssuerContainsFold *string  `json:"issuerContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PublicJWKWhereInput) AddPredicates(predicates ...predicate.PublicJWK) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PublicJWKWhereInput filter on the PublicJWKQuery builder.
func (i *PublicJWKWhereInput) Filter(q *PublicJWKQuery) (*PublicJWKQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPublicJWKWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPublicJWKWhereInput is returned in case the PublicJWKWhereInput is empty.
var ErrEmptyPublicJWKWhereInput = errors.New("ent: empty predicate PublicJWKWhereInput")

// P returns a predicate for filtering publicjwks.
// An error is returned if the input is empty or invalid.
func (i *PublicJWKWhereInput) P() (predicate.PublicJWK, error) {
	var predicates []predicate.PublicJWK
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, publicjwk.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PublicJWK, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, publicjwk.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PublicJWK, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, publicjwk.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, publicjwk.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, publicjwk.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, publicjwk.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, publicjwk.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, publicjwk.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, publicjwk.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, publicjwk.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, publicjwk.IDLTE(*i.IDLTE))
	}
	if i.Sid != nil {
		predicates = append(predicates, publicjwk.SidEQ(*i.Sid))
	}
	if i.SidNEQ != nil {
		predicates = append(predicates, publicjwk.SidNEQ(*i.SidNEQ))
	}
	if len(i.SidIn) > 0 {
		predicates = append(predicates, publicjwk.SidIn(i.SidIn...))
	}
	if len(i.SidNotIn) > 0 {
		predicates = append(predicates, publicjwk.SidNotIn(i.SidNotIn...))
	}
	if i.SidGT != nil {
		predicates = append(predicates, publicjwk.SidGT(*i.SidGT))
	}
	if i.SidGTE != nil {
		predicates = append(predicates, publicjwk.SidGTE(*i.SidGTE))
	}
	if i.SidLT != nil {
		predicates = append(predicates, publicjwk.SidLT(*i.SidLT))
	}
	if i.SidLTE != nil {
		predicates = append(predicates, publicjwk.SidLTE(*i.SidLTE))
	}
	if i.SidContains != nil {
		predicates = append(predicates, publicjwk.SidContains(*i.SidContains))
	}
	if i.SidHasPrefix != nil {
		predicates = append(predicates, publicjwk.SidHasPrefix(*i.SidHasPrefix))
	}
	if i.SidHasSuffix != nil {
		predicates = append(predicates, publicjwk.SidHasSuffix(*i.SidHasSuffix))
	}
	if i.SidEqualFold != nil {
		predicates = append(predicates, publicjwk.SidEqualFold(*i.SidEqualFold))
	}
	if i.SidContainsFold != nil {
		predicates = append(predicates, publicjwk.SidContainsFold(*i.SidContainsFold))
	}
	if i.Kid != nil {
		predicates = append(predicates, publicjwk.KidEQ(*i.Kid))
	}
	if i.KidNEQ != nil {
		predicates = append(predicates, publicjwk.KidNEQ(*i.KidNEQ))
	}
	if len(i.KidIn) > 0 {
		predicates = append(predicates, publicjwk.KidIn(i.KidIn...))
	}
	if len(i.KidNotIn) > 0 {
		predicates = append(predicates, publicjwk.KidNotIn(i.KidNotIn...))
	}
	if i.KidGT != nil {
		predicates = append(predicates, publicjwk.KidGT(*i.KidGT))
	}
	if i.KidGTE != nil {
		predicates = append(predicates, publicjwk.KidGTE(*i.KidGTE))
	}
	if i.KidLT != nil {
		predicates = append(predicates, publicjwk.KidLT(*i.KidLT))
	}
	if i.KidLTE != nil {
		predicates = append(predicates, publicjwk.KidLTE(*i.KidLTE))
	}
	if i.KidContains != nil {
		predicates = append(predicates, publicjwk.KidContains(*i.KidContains))
	}
	if i.KidHasPrefix != nil {
		predicates = append(predicates, publicjwk.KidHasPrefix(*i.KidHasPrefix))
	}
	if i.KidHasSuffix != nil {
		predicates = append(predicates, publicjwk.KidHasSuffix(*i.KidHasSuffix))
	}
	if i.KidEqualFold != nil {
		predicates = append(predicates, publicjwk.KidEqualFold(*i.KidEqualFold))
	}
	if i.KidContainsFold != nil {
		predicates = append(predicates, publicjwk.KidContainsFold(*i.KidContainsFold))
	}
	if i.Key != nil {
		predicates = append(predicates, publicjwk.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, publicjwk.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, publicjwk.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, publicjwk.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, publicjwk.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, publicjwk.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, publicjwk.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, publicjwk.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, publicjwk.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, publicjwk.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, publicjwk.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, publicjwk.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, publicjwk.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.Issuer != nil {
		predicates = append(predicates, publicjwk.IssuerEQ(*i.Issuer))
	}
	if i.IssuerNEQ != nil {
		predicates = append(predicates, publicjwk.IssuerNEQ(*i.IssuerNEQ))
	}
	if len(i.IssuerIn) > 0 {
		predicates = append(predicates, publicjwk.IssuerIn(i.IssuerIn...))
	}
	if len(i.IssuerNotIn) > 0 {
		predicates = append(predicates, publicjwk.IssuerNotIn(i.IssuerNotIn...))
	}
	if i.IssuerGT != nil {
		predicates = append(predicates, publicjwk.IssuerGT(*i.IssuerGT))
	}
	if i.IssuerGTE != nil {
		predicates = append(predicates, publicjwk.IssuerGTE(*i.IssuerGTE))
	}
	if i.IssuerLT != nil {
		predicates = append(predicates, publicjwk.IssuerLT(*i.IssuerLT))
	}
	if i.IssuerLTE != nil {
		predicates = append(predicates, publicjwk.IssuerLTE(*i.IssuerLTE))
	}
	if i.IssuerContains != nil {
		predicates = append(predicates, publicjwk.IssuerContains(*i.IssuerContains))
	}
	if i.IssuerHasPrefix != nil {
		predicates = append(predicates, publicjwk.IssuerHasPrefix(*i.IssuerHasPrefix))
	}
	if i.IssuerHasSuffix != nil {
		predicates = append(predicates, publicjwk.IssuerHasSuffix(*i.IssuerHasSuffix))
	}
	if i.IssuerEqualFold != nil {
		predicates = append(predicates, publicjwk.IssuerEqualFold(*i.IssuerEqualFold))
	}
	if i.IssuerContainsFold != nil {
		predicates = append(predicates, publicjwk.IssuerContainsFold(*i.IssuerContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPublicJWKWhereInput
	case 1:
		return predicates[0], nil
	default:
		return publicjwk.And(predicates...), nil
	}
}

// PublicJWKSetWhereInput represents a where input for filtering PublicJWKSet queries.
type PublicJWKSetWhereInput struct {
	Predicates []predicate.PublicJWKSet  `json:"-"`
	Not        *PublicJWKSetWhereInput   `json:"not,omitempty"`
	Or         []*PublicJWKSetWhereInput `json:"or,omitempty"`
	And        []*PublicJWKSetWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PublicJWKSetWhereInput) AddPredicates(predicates ...predicate.PublicJWKSet) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PublicJWKSetWhereInput filter on the PublicJWKSetQuery builder.
func (i *PublicJWKSetWhereInput) Filter(q *PublicJWKSetQuery) (*PublicJWKSetQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPublicJWKSetWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPublicJWKSetWhereInput is returned in case the PublicJWKSetWhereInput is empty.
var ErrEmptyPublicJWKSetWhereInput = errors.New("ent: empty predicate PublicJWKSetWhereInput")

// P returns a predicate for filtering publicjwksets.
// An error is returned if the input is empty or invalid.
func (i *PublicJWKSetWhereInput) P() (predicate.PublicJWKSet, error) {
	var predicates []predicate.PublicJWKSet
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, publicjwkset.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PublicJWKSet, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, publicjwkset.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PublicJWKSet, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, publicjwkset.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, publicjwkset.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, publicjwkset.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, publicjwkset.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, publicjwkset.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, publicjwkset.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, publicjwkset.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, publicjwkset.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, publicjwkset.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPublicJWKSetWhereInput
	case 1:
		return predicates[0], nil
	default:
		return publicjwkset.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "Name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "OAuthID" field predicates.
	OAuthID             *string  `json:"oauthid,omitempty"`
	OAuthIDNEQ          *string  `json:"oauthidNEQ,omitempty"`
	OAuthIDIn           []string `json:"oauthidIn,omitempty"`
	OAuthIDNotIn        []string `json:"oauthidNotIn,omitempty"`
	OAuthIDGT           *string  `json:"oauthidGT,omitempty"`
	OAuthIDGTE          *string  `json:"oauthidGTE,omitempty"`
	OAuthIDLT           *string  `json:"oauthidLT,omitempty"`
	OAuthIDLTE          *string  `json:"oauthidLTE,omitempty"`
	OAuthIDContains     *string  `json:"oauthidContains,omitempty"`
	OAuthIDHasPrefix    *string  `json:"oauthidHasPrefix,omitempty"`
	OAuthIDHasSuffix    *string  `json:"oauthidHasSuffix,omitempty"`
	OAuthIDEqualFold    *string  `json:"oauthidEqualFold,omitempty"`
	OAuthIDContainsFold *string  `json:"oauthidContainsFold,omitempty"`

	// "IsActivated" field predicates.
	IsActivated    *bool `json:"isactivated,omitempty"`
	IsActivatedNEQ *bool `json:"isactivatedNEQ,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}
	if i.OAuthID != nil {
		predicates = append(predicates, user.OAuthIDEQ(*i.OAuthID))
	}
	if i.OAuthIDNEQ != nil {
		predicates = append(predicates, user.OAuthIDNEQ(*i.OAuthIDNEQ))
	}
	if len(i.OAuthIDIn) > 0 {
		predicates = append(predicates, user.OAuthIDIn(i.OAuthIDIn...))
	}
	if len(i.OAuthIDNotIn) > 0 {
		predicates = append(predicates, user.OAuthIDNotIn(i.OAuthIDNotIn...))
	}
	if i.OAuthIDGT != nil {
		predicates = append(predicates, user.OAuthIDGT(*i.OAuthIDGT))
	}
	if i.OAuthIDGTE != nil {
		predicates = append(predicates, user.OAuthIDGTE(*i.OAuthIDGTE))
	}
	if i.OAuthIDLT != nil {
		predicates = append(predicates, user.OAuthIDLT(*i.OAuthIDLT))
	}
	if i.OAuthIDLTE != nil {
		predicates = append(predicates, user.OAuthIDLTE(*i.OAuthIDLTE))
	}
	if i.OAuthIDContains != nil {
		predicates = append(predicates, user.OAuthIDContains(*i.OAuthIDContains))
	}
	if i.OAuthIDHasPrefix != nil {
		predicates = append(predicates, user.OAuthIDHasPrefix(*i.OAuthIDHasPrefix))
	}
	if i.OAuthIDHasSuffix != nil {
		predicates = append(predicates, user.OAuthIDHasSuffix(*i.OAuthIDHasSuffix))
	}
	if i.OAuthIDEqualFold != nil {
		predicates = append(predicates, user.OAuthIDEqualFold(*i.OAuthIDEqualFold))
	}
	if i.OAuthIDContainsFold != nil {
		predicates = append(predicates, user.OAuthIDContainsFold(*i.OAuthIDContainsFold))
	}
	if i.IsActivated != nil {
		predicates = append(predicates, user.IsActivatedEQ(*i.IsActivated))
	}
	if i.IsActivatedNEQ != nil {
		predicates = append(predicates, user.IsActivatedNEQ(*i.IsActivatedNEQ))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
